!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
-interaction	xbraid/docs/Makefile	/^	if test -d developer_manual; then cd developer_manual; sed 's\/pdflatex\/pdflatex --interaction=nonstopmode\/g' Makefile > Makefile.temp; mv Makefile.temp Makefile; fi$/;"	m
-interaction	xbraid/docs/Makefile	/^	if test -d user_manual; then cd user_manual; sed 's\/pdflatex\/pdflatex --interaction=nonstopmode\/g' Makefile > Makefile.temp; mv Makefile.temp Makefile; fi$/;"	m
.*|^	xbraid/test/adjoint.sh	/^lines_to_check="^  time steps.*|^  number of levels.*|^  iterations.*|^  residual norm.*|^  state   residual.*|^  adjoint residual.*|^  Objective function.*|^  Gradient norm.*|^  optimization iterations.*|^Finished braid_TestAll: no fails detected, however some results must be|.*Braid: Temporal refinement occurred.*|^255.*|^  3 .*"$/;"	f
../img/logo_with_subtext.pdf	xbraid/docs/developer_manual_header.tex	/^     \\includegraphics[width=0.7\\textwidth]{..\/img\/logo_with_subtext.pdf}$/;"	g
../img/logo_with_subtext.pdf	xbraid/docs/user_manual_header.tex	/^     \\includegraphics[width=0.7\\textwidth]{..\/img\/logo_with_subtext.pdf}$/;"	g
A	include/hessianApprox.hpp	/^      MyReal* A;$/;"	m	class:BFGS
A	xbraid/drivers/mfem_arnoldi.hpp	/^        DenseMatrix & A;$/;"	m	class:DenseMatrixTimeDependentOperator
A	xbraid/drivers/mfem_arnoldi.hpp	/^        Operator *A;$/;"	m	class:Arnoldi
ACCESS	xbraid/braid/_braid_tape.h	/^   ACCESS     = 8,$/;"	e	enum:_braid_Call_enum
ACCESSOR_HEADER_GET1	xbraid/braid/braid_status.h	45;"	d
ACCESSOR_HEADER_GET2	xbraid/braid/braid_status.h	47;"	d
ACCESSOR_HEADER_GET4	xbraid/braid/braid_status.h	49;"	d
ACCESSOR_HEADER_GET5	xbraid/braid/braid_status.h	51;"	d
ACCESSOR_HEADER_SET1	xbraid/braid/braid_status.h	53;"	d
ALL_EXAMPLES	xbraid/drivers/Makefile	/^ALL_EXAMPLES := $(patsubst %.c,%,$(ALL_EXAMPLES))$/;"	m
ALL_EXAMPLES	xbraid/drivers/Makefile	/^ALL_EXAMPLES := $(patsubst %.cpp,%,$(wildcard *.c *.cpp))$/;"	m
Access	xbraid/drivers/braid_mfem.hpp	/^int MFEMBraidApp::Access(braid_Vector       u_,$/;"	f	class:MFEMBraidApp
Access	xbraid/drivers/braid_mfem_block.hpp	/^int MFEMBraidApp::Access(braid_Vector u_, BraidAccessStatus &astatus)$/;"	f	class:MFEMBraidApp
AddMeshOptions	xbraid/drivers/braid_mfem.hpp	/^void BraidOptions::AddMeshOptions()$/;"	f	class:BraidOptions
AddMeshOptions	xbraid/drivers/braid_mfem_block.hpp	/^void BraidOptions::AddMeshOptions()$/;"	f	class:BraidOptions
AllocLevels	xbraid/drivers/braid_mfem.hpp	/^   virtual void AllocLevels(int num_levels) { }$/;"	f	class:MFEMBraidApp
AllocLevels	xbraid/drivers/braid_mfem_block.hpp	/^    virtual void AllocLevels(int num_space_levels) { }$/;"	f	class:MFEMBraidApp
ApplyV	xbraid/drivers/mfem_arnoldi.hpp	/^        void ApplyV(const Vector & ubar, Vector & u)$/;"	f	class:Arnoldi
ApplyVT	xbraid/drivers/mfem_arnoldi.hpp	/^        void ApplyVT(const Vector & u, Vector & ubar)$/;"	f	class:Arnoldi
Arnoldi	xbraid/drivers/mfem_arnoldi.hpp	/^        Arnoldi(int k_max_, MPI_Comm comm_)$/;"	f	class:Arnoldi
Arnoldi	xbraid/drivers/mfem_arnoldi.hpp	/^class Arnoldi$/;"	c
B	include/hessianApprox.hpp	/^      MyReal* B;$/;"	m	class:BFGS
BACKTRACKINGLS	include/config.hpp	/^enum stepsizetype{FIXED, BACKTRACKINGLS, ONEOVERK};$/;"	e	enum:stepsizetype
BFGS	include/hessianApprox.hpp	/^class BFGS : public HessianApprox {$/;"	c
BFGS_SERIAL	include/config.hpp	/^enum hessiantype{BFGS_SERIAL, LBFGS, IDENTITY};$/;"	e	enum:hessiantype
BRAID_DIR	xbraid/drivers/Makefile	/^BRAID_DIR=..\/braid$/;"	m
BRAID_DIR	xbraid/examples/Makefile	/^BRAID_DIR=..\/braid$/;"	m
BRAID_FILES	xbraid/braid/Makefile	/^BRAID_FILES = _util.c braid.c _braid.c braid_test.c _braid_status.c braid_F90_iface.c _braid_base.c  _braid_tape.c$/;"	m
BRAID_FLAGS	xbraid/drivers/Makefile	/^BRAID_FLAGS = -I$(BRAID_DIR)$/;"	m
BRAID_FLAGS	xbraid/examples/Makefile	/^BRAID_FLAGS = -I$(BRAID_DIR)$/;"	m
BRAID_HEADERS	xbraid/braid/Makefile	/^BRAID_HEADERS = _braid.h braid.h _util.h braid_test.h braid_status.h braid_defs.h _braid_base.h _braid_tape.h$/;"	m
BRAID_INC_DIR	Makefile	/^BRAID_INC_DIR = xbraid\/braid$/;"	m
BRAID_LIB_FILE	Makefile	/^BRAID_LIB_FILE = xbraid\/braid\/libbraid.a$/;"	m
BRAID_LIB_FILE	xbraid/drivers/Makefile	/^BRAID_LIB_FILE = $(BRAID_DIR)\/libbraid.a$/;"	m
BRAID_LIB_FILE	xbraid/examples/Makefile	/^BRAID_LIB_FILE = $(BRAID_DIR)\/libbraid.a$/;"	m
BRAID_OBJ	xbraid/braid/Makefile	/^BRAID_OBJ = $(BRAID_FILES:.c=.o)$/;"	m
BUFPACK	xbraid/braid/_braid_tape.h	/^   BUFPACK    = 6,$/;"	e	enum:_braid_Call_enum
BUFUNPACK	xbraid/braid/_braid_tape.h	/^   BUFUNPACK  = 7,$/;"	e	enum:_braid_Call_enum
BUILD_DIR	Makefile	/^BUILD_DIR = build$/;"	m
BraidAccessStatus	xbraid/braid/braid.hpp	/^      BraidAccessStatus(braid_AccessStatus _astatus)$/;"	f	class:BraidAccessStatus
BraidAccessStatus	xbraid/braid/braid.hpp	/^class BraidAccessStatus$/;"	c
BraidApp	xbraid/braid/braid.hpp	/^   BraidApp(MPI_Comm   _comm_t,$/;"	f	class:BraidApp
BraidApp	xbraid/braid/braid.hpp	/^class BraidApp$/;"	c
BraidBufferStatus	xbraid/braid/braid.hpp	/^      BraidBufferStatus( braid_BufferStatus _bstatus )$/;"	f	class:BraidBufferStatus
BraidBufferStatus	xbraid/braid/braid.hpp	/^class BraidBufferStatus$/;"	c
BraidCoarsenRefStatus	xbraid/braid/braid.hpp	/^      BraidCoarsenRefStatus(braid_CoarsenRefStatus  _cstatus)$/;"	f	class:BraidCoarsenRefStatus
BraidCoarsenRefStatus	xbraid/braid/braid.hpp	/^class BraidCoarsenRefStatus$/;"	c
BraidCore	xbraid/braid/braid.hpp	/^   BraidCore(MPI_Comm comm_world, BraidApp *app)$/;"	f	class:BraidCore
BraidCore	xbraid/braid/braid.hpp	/^class BraidCore$/;"	c
BraidOptions	xbraid/drivers/braid_mfem.hpp	/^BraidOptions::BraidOptions(int argc, char *argv[])$/;"	f	class:BraidOptions
BraidOptions	xbraid/drivers/braid_mfem.hpp	/^struct BraidOptions : public OptionsParser$/;"	s
BraidOptions	xbraid/drivers/braid_mfem_block.hpp	/^BraidOptions::BraidOptions(int argc, char *argv[])$/;"	f	class:BraidOptions
BraidOptions	xbraid/drivers/braid_mfem_block.hpp	/^struct BraidOptions : public OptionsParser$/;"	s
BraidStepStatus	xbraid/braid/braid.hpp	/^      BraidStepStatus(braid_StepStatus _pstatus)$/;"	f	class:BraidStepStatus
BraidStepStatus	xbraid/braid/braid.hpp	/^class BraidStepStatus$/;"	c
BraidUtil	xbraid/braid/braid.hpp	/^   BraidUtil() { }$/;"	f	class:BraidUtil
BraidUtil	xbraid/braid/braid.hpp	/^class BraidUtil$/;"	c
BraidVector	xbraid/drivers/braid_mfem.hpp	/^   BraidVector(const BraidVector &source_vector)$/;"	f	class:BraidVector
BraidVector	xbraid/drivers/braid_mfem.hpp	/^   BraidVector(int source_level, ParFiniteElementSpace *pfes)$/;"	f	class:BraidVector
BraidVector	xbraid/drivers/braid_mfem.hpp	/^   BraidVector(int source_level, const HypreParVector &source_vector)$/;"	f	class:BraidVector
BraidVector	xbraid/drivers/braid_mfem.hpp	/^class BraidVector : public HypreParVector$/;"	c
BraidVector	xbraid/drivers/braid_mfem_block.hpp	/^BraidVector::BraidVector(const BraidVector &source_vector)$/;"	f	class:BraidVector
BraidVector	xbraid/drivers/braid_mfem_block.hpp	/^BraidVector::BraidVector(int source_level, const Array<int> &bOffsets)$/;"	f	class:BraidVector
BraidVector	xbraid/drivers/braid_mfem_block.hpp	/^BraidVector::BraidVector(int source_level, const BlockVector &source_vector)$/;"	f	class:BraidVector
BraidVector	xbraid/drivers/braid_mfem_block.hpp	/^class BraidVector : public BlockVector$/;"	c
BufPack	xbraid/drivers/braid_mfem.hpp	/^int MFEMBraidApp::BufPack(braid_Vector       u_,$/;"	f	class:MFEMBraidApp
BufPack	xbraid/drivers/braid_mfem_block.hpp	/^int MFEMBraidApp::BufPack(braid_Vector        u_, $/;"	f	class:MFEMBraidApp
BufSize	xbraid/drivers/braid_mfem.hpp	/^int MFEMBraidApp::BufSize(int                *size_ptr,$/;"	f	class:MFEMBraidApp
BufSize	xbraid/drivers/braid_mfem_block.hpp	/^int MFEMBraidApp::BufSize(int                *size_ptr,$/;"	f	class:MFEMBraidApp
BufUnpack	xbraid/drivers/braid_mfem.hpp	/^int MFEMBraidApp::BufUnpack(void              *buffer,$/;"	f	class:MFEMBraidApp
BufUnpack	xbraid/drivers/braid_mfem_block.hpp	/^int MFEMBraidApp::BufUnpack(void              *buffer,$/;"	f	class:MFEMBraidApp
CC	Makefile	/^CC     = mpicc$/;"	m
CLASSIFICATION	include/layer.hpp	/^      enum layertype{OPENZERO=0, OPENDENSE=1, DENSE=2, CLASSIFICATION=3, OPENCONV=4, OPENCONVMNIST=5, CONVOLUTION=6};$/;"	e	enum:Layer::layertype
CLONE	xbraid/braid/_braid_tape.h	/^   CLONE      = 3,$/;"	e	enum:_braid_Call_enum
CONFIG_ARG_MAX_BYTES	include/config.hpp	7;"	d
CONVOLUTION	include/layer.hpp	/^      enum layertype{OPENZERO=0, OPENDENSE=1, DENSE=2, CLASSIFICATION=3, OPENCONV=4, OPENCONVMNIST=5, CONVOLUTION=6};$/;"	e	enum:Layer::layertype
CONVOLUTIONAL	include/config.hpp	/^enum networkType{DENSE, CONVOLUTIONAL}; $/;"	e	enum:networkType
CXX	Makefile	/^CXX    = mpicxx$/;"	m
CXX_EXAMPLES	xbraid/drivers/Makefile	/^CXX_EXAMPLES = drive-diffusion-1D-moving-mesh drive-diffusion-1D-moving-mesh-serial \\$/;"	m
CXX_FLAGS	Makefile	/^CXX_FLAGS = -g -Wall -pedantic -lm -Wno-write-strings -Wno-delete-non-virtual-dtor -std=c++11$/;"	m
C_EXAMPLES	xbraid/drivers/Makefile	/^C_EXAMPLES = drive-burgers-1D drive-diffusion-2D drive-lorenz$/;"	m
C_EXAMPLES	xbraid/examples/Makefile	/^C_EXAMPLES = ex-03 ex-03-serial$/;"	m
C_NOHYPRE	xbraid/examples/Makefile	/^C_NOHYPRE = ex-01 ex-01-adjoint ex-01-optimization ex-01-refinement ex-01-expanded ex-01-expanded-bdf2 ex-02 ex-04 ex-04-serial$/;"	m
ClassificationLayer	include/layer.hpp	/^class ClassificationLayer : public Layer$/;"	c
Clone	xbraid/drivers/braid_mfem.hpp	/^int MFEMBraidApp::Clone(braid_Vector  u_,$/;"	f	class:MFEMBraidApp
Clone	xbraid/drivers/braid_mfem_block.hpp	/^int MFEMBraidApp::Clone(braid_Vector  u_,$/;"	f	class:MFEMBraidApp
Coarsen	xbraid/braid/braid.hpp	/^   virtual braid_Int Coarsen(braid_Vector           fu_,$/;"	f	class:BraidApp
Coarsen	xbraid/drivers/braid_mfem.hpp	/^int MFEMBraidApp::Coarsen(braid_Vector   fu_,$/;"	f	class:MFEMBraidApp
Coarsen	xbraid/drivers/braid_mfem_block.hpp	/^int MFEMBraidApp::Coarsen(braid_Vector fu_, braid_Vector  *cu_ptr, BraidCoarsenRefStatus &status)$/;"	f	class:MFEMBraidApp
ComputeMeshSize	xbraid/drivers/braid_mfem.hpp	/^void SpaceTimeMeshInfo::ComputeMeshSize( ParMesh *pmesh, double * h_min_ptr, double * h_max_ptr)$/;"	f	class:SpaceTimeMeshInfo
ComputeMeshSize	xbraid/drivers/braid_mfem_block.hpp	/^void SpaceTimeMeshInfo::ComputeMeshSize( ParMesh *pmesh, double * h_min_ptr, double * h_max_ptr)$/;"	f	class:SpaceTimeMeshInfo
ComputeSpaceLevel	xbraid/drivers/braid_mfem.hpp	/^int MFEMBraidApp::ComputeSpaceLevel(double tstart, double tprior, double tstop)$/;"	f	class:MFEMBraidApp
ComputeSpaceLevel	xbraid/drivers/braid_mfem_block.hpp	/^int MFEMBraidApp::ComputeSpaceLevel(double tstart, double tprior, double tstop)$/;"	f	class:MFEMBraidApp
Config	include/config.hpp	/^class Config {$/;"	c
Config	pythonutil/config.py	/^class Config(OrderedBunch):$/;"	c
ConstructFESpace	xbraid/drivers/braid_mfem.hpp	/^ParFiniteElementSpace *MFEMBraidApp::ConstructFESpace(ParMesh *pmesh)$/;"	f	class:MFEMBraidApp
ConstructFESpace	xbraid/drivers/braid_mfem_block.hpp	/^ParFiniteElementSpace *MFEMBraidApp::ConstructFESpace(ParMesh *pmesh)$/;"	f	class:MFEMBraidApp
ConvLayer	include/layer.hpp	/^class ConvLayer : public Layer {$/;"	c
DENSE	include/config.hpp	/^enum networkType{DENSE, CONVOLUTIONAL}; $/;"	e	enum:networkType
DENSE	include/layer.hpp	/^      enum layertype{OPENZERO=0, OPENDENSE=1, DENSE=2, CLASSIFICATION=3, OPENCONV=4, OPENCONVMNIST=5, CONVOLUTION=6};$/;"	e	enum:Layer::layertype
DETERMINISTIC	include/config.hpp	/^enum batchtype{DETERMINISTIC, STOCHASTIC};$/;"	e	enum:batchtype
DOX	xbraid/docs/Makefile	/^DOX=doxygen$/;"	m
DOXVERSION	xbraid/docs/Makefile	/^DOXVERSION := $(shell expr `doxygen --version | sed -e 's\/\\.\\([0-9][0-9]\\)\/\\1\/g' -e 's\/\\.\\([0-9]\\)\/0\\1\/g' -e 's\/^[0-9]\\{3,4\\}$$\/&00\/'` \\>= 10800)$/;"	m
DataSet	include/dataset.hpp	/^class DataSet {$/;"	c
DenseLayer	include/layer.hpp	/^class DenseLayer : public Layer {$/;"	c
DenseMatrixTimeDependentOperator	xbraid/drivers/mfem_arnoldi.hpp	/^        DenseMatrixTimeDependentOperator(DenseMatrix & A_) : TimeDependentOperator(A_.Width()), A(A_) {}$/;"	f	class:DenseMatrixTimeDependentOperator
DenseMatrixTimeDependentOperator	xbraid/drivers/mfem_arnoldi.hpp	/^class DenseMatrixTimeDependentOperator : public TimeDependentOperator$/;"	c
Dot	xbraid/drivers/mfem_arnoldi.hpp	/^        double Dot(const Vector &x, const Vector &y) const$/;"	f	class:Arnoldi
Drive	xbraid/braid/braid.hpp	/^   void Drive() { braid_Drive(core); }$/;"	f	class:BraidCore
EvalBufSize	xbraid/drivers/braid_mfem.hpp	/^   static int EvalBufSize(int vector_size)$/;"	f	class:MFEMBraidApp
EvalBufSize	xbraid/drivers/braid_mfem_block.hpp	/^    static int EvalBufSize(int vector_size)$/;"	f	class:MFEMBraidApp
FIXED	include/config.hpp	/^enum stepsizetype{FIXED, BACKTRACKINGLS, ONEOVERK};$/;"	e	enum:stepsizetype
FREE	xbraid/braid/_braid_tape.h	/^   FREE       = 4,$/;"	e	enum:_braid_Call_enum
F_NOHYPRE	xbraid/examples/Makefile	/^F_NOHYPRE = ex-01-expanded-f$/;"	m
Free	xbraid/drivers/braid_mfem.hpp	/^int MFEMBraidApp::Free(braid_Vector u_)$/;"	f	class:MFEMBraidApp
Free	xbraid/drivers/braid_mfem_block.hpp	/^int MFEMBraidApp::Free(braid_Vector u_)$/;"	f	class:MFEMBraidApp
GenKrylovSpace	xbraid/drivers/mfem_arnoldi.hpp	/^        void GenKrylovSpace(const Vector & u)$/;"	f	class:Arnoldi
GetCTprior	xbraid/braid/braid.hpp	/^      void GetCTprior(braid_Real *c_tprior_ptr) { braid_CoarsenRefStatusGetCTprior(cstatus, c_tprior_ptr); }$/;"	f	class:BraidCoarsenRefStatus
GetCTstop	xbraid/braid/braid.hpp	/^      void GetCTstop(braid_Real *c_tstop_ptr)   { braid_CoarsenRefStatusGetCTstop(cstatus, c_tstop_ptr); }$/;"	f	class:BraidCoarsenRefStatus
GetCore	xbraid/braid/braid.hpp	/^   braid_Core GetCore() { return core; };$/;"	f	class:BraidCore
GetDistribution	xbraid/braid/braid.hpp	/^   void GetDistribution(braid_Int *ilower_ptr, braid_Int *iupper_ptr) { _braid_GetDistribution(core, ilower_ptr, iupper_ptr); };$/;"	f	class:BraidCore
GetDone	xbraid/braid/braid.hpp	/^      void GetDone(braid_Int *done_ptr)         { braid_AccessStatusGetDone(astatus, done_ptr); }$/;"	f	class:BraidAccessStatus
GetFTprior	xbraid/braid/braid.hpp	/^      void GetFTprior(braid_Real *f_tprior_ptr) { braid_CoarsenRefStatusGetFTprior(cstatus, f_tprior_ptr); }$/;"	f	class:BraidCoarsenRefStatus
GetFTstop	xbraid/braid/braid.hpp	/^      void GetFTstop(braid_Real *f_tstop_ptr)   { braid_CoarsenRefStatusGetFTstop(cstatus, f_tstop_ptr); }$/;"	f	class:BraidCoarsenRefStatus
GetH	xbraid/drivers/mfem_arnoldi.hpp	/^        TimeDependentOperator & GetH( )$/;"	f	class:Arnoldi
GetIter	xbraid/braid/braid.hpp	/^      void GetIter(braid_Int *iter_ptr)                  { braid_StepStatusGetIter(pstatus, iter_ptr); }$/;"	f	class:BraidStepStatus
GetIter	xbraid/braid/braid.hpp	/^      void GetIter(braid_Int *iter_ptr)         { braid_AccessStatusGetIter(astatus, iter_ptr); }$/;"	f	class:BraidAccessStatus
GetLevel	xbraid/braid/braid.hpp	/^      void GetLevel(braid_Int *level_ptr)                { braid_StepStatusGetLevel(pstatus, level_ptr); }$/;"	f	class:BraidStepStatus
GetLevel	xbraid/braid/braid.hpp	/^      void GetLevel(braid_Int *level_ptr)       { braid_AccessStatusGetLevel(astatus, level_ptr); }$/;"	f	class:BraidAccessStatus
GetLevel	xbraid/braid/braid.hpp	/^      void GetLevel(braid_Int *level_ptr)       { braid_CoarsenRefStatusGetLevel(cstatus, level_ptr); }$/;"	f	class:BraidCoarsenRefStatus
GetMessageType	xbraid/braid/braid.hpp	/^      void GetMessageType( braid_Int *messagetype_ptr ) { braid_BufferStatusGetMessageType( bstatus, messagetype_ptr); }$/;"	f	class:BraidBufferStatus
GetNLevels	xbraid/braid/braid.hpp	/^      void GetNLevels(braid_Int *nlevels_ptr)            { braid_StepStatusGetNLevels(pstatus, nlevels_ptr); }$/;"	f	class:BraidStepStatus
GetNLevels	xbraid/braid/braid.hpp	/^      void GetNLevels(braid_Int *nlevels_ptr)   { braid_AccessStatusGetNLevels(astatus, nlevels_ptr);}$/;"	f	class:BraidAccessStatus
GetNLevels	xbraid/braid/braid.hpp	/^      void GetNLevels(braid_Int *nlevels_ptr)   { braid_CoarsenRefStatusGetNLevels(cstatus, nlevels_ptr); }$/;"	f	class:BraidCoarsenRefStatus
GetNLevels	xbraid/braid/braid.hpp	/^   void GetNLevels(braid_Int *nlevels_ptr) { braid_GetNLevels(core, nlevels_ptr); }$/;"	f	class:BraidCore
GetNRefine	xbraid/braid/braid.hpp	/^      void GetNRefine(braid_Int *nrefine_ptr)            { braid_StepStatusGetNRefine(pstatus, nrefine_ptr); }$/;"	f	class:BraidStepStatus
GetNRefine	xbraid/braid/braid.hpp	/^      void GetNRefine(braid_Int *nrefine_ptr)   { braid_AccessStatusGetNRefine(astatus, nrefine_ptr); }$/;"	f	class:BraidAccessStatus
GetNRefine	xbraid/braid/braid.hpp	/^      void GetNRefine(braid_Int *nrefine_ptr)   { braid_CoarsenRefStatusGetNRefine(cstatus, nrefine_ptr); }$/;"	f	class:BraidCoarsenRefStatus
GetNumBlocks	xbraid/drivers/braid_mfem_block.hpp	/^void BraidVector::GetNumBlocks(int &blocks)$/;"	f	class:BraidVector
GetNumIter	xbraid/braid/braid.hpp	/^   void GetNumIter(braid_Int *niter_ptr) { braid_GetNumIter(core, niter_ptr); }$/;"	f	class:BraidCore
GetNumSpaceLevels	xbraid/drivers/braid_mfem.hpp	/^   int GetNumSpaceLevels() const { return ode.Size(); }$/;"	f	class:MFEMBraidApp
GetNumSpaceLevels	xbraid/drivers/braid_mfem_block.hpp	/^    int GetNumSpaceLevels() const { return ode.Size(); }$/;"	f	class:MFEMBraidApp
GetOffsetsPtr	xbraid/drivers/braid_mfem_block.hpp	/^void BraidVector::GetOffsetsPtr(const int *&address)$/;"	f	class:BraidVector
GetOldFineTolx	xbraid/braid/braid.hpp	/^      void GetOldFineTolx(braid_Real *old_fine_tolx_ptr) { braid_StepStatusGetOldFineTolx(pstatus, old_fine_tolx_ptr); }$/;"	f	class:BraidStepStatus
GetRNorms	xbraid/braid/braid.hpp	/^      void GetRNorms(braid_Int *nrequest_ptr, braid_Real *rnorms)$/;"	f	class:BraidStepStatus
GetRNorms	xbraid/braid/braid.hpp	/^   void GetRNorms(braid_Int *nrequest_ptr, braid_Real *rnorms) { braid_GetRNorms(core, nrequest_ptr, rnorms); }$/;"	f	class:BraidCore
GetResidual	xbraid/braid/braid.hpp	/^      void GetResidual(braid_Real *rnorm_ptr)   { braid_AccessStatusGetResidual(astatus, rnorm_ptr); }$/;"	f	class:BraidAccessStatus
GetSpatialAccuracy	xbraid/braid/braid.hpp	/^   void GetSpatialAccuracy(braid_StepStatus  sstatus,$/;"	f	class:BraidUtil
GetT	xbraid/braid/braid.hpp	/^      void GetT(braid_Real *t_ptr)              { braid_AccessStatusGetT(astatus, t_ptr); }$/;"	f	class:BraidAccessStatus
GetT	xbraid/braid/braid.hpp	/^      void GetT(braid_Real *tstart_ptr)                  { braid_StepStatusGetT(pstatus, tstart_ptr); }$/;"	f	class:BraidStepStatus
GetT	xbraid/braid/braid.hpp	/^      void GetT(braid_Real *tstart_ptr)         { braid_CoarsenRefStatusGetT(cstatus, tstart_ptr); }$/;"	f	class:BraidCoarsenRefStatus
GetTILD	xbraid/braid/braid.hpp	/^      void GetTILD(braid_Real *t_ptr,$/;"	f	class:BraidAccessStatus
GetTIndex	xbraid/braid/braid.hpp	/^      void GetTIndex(braid_Int *tindex_ptr)              { braid_StepStatusGetTIndex(pstatus, tindex_ptr); }$/;"	f	class:BraidStepStatus
GetTIndex	xbraid/braid/braid.hpp	/^      void GetTIndex(braid_Int *tindex_ptr)     { braid_AccessStatusGetTIndex(astatus, tindex_ptr); }$/;"	f	class:BraidAccessStatus
GetTIndex	xbraid/braid/braid.hpp	/^      void GetTIndex(braid_Int *tindex_ptr)     { braid_CoarsenRefStatusGetTIndex(cstatus, tindex_ptr); }$/;"	f	class:BraidCoarsenRefStatus
GetTpriorTstop	xbraid/braid/braid.hpp	/^      void GetTpriorTstop(braid_Real *tstart_ptr,$/;"	f	class:BraidCoarsenRefStatus
GetTstartTstop	xbraid/braid/braid.hpp	/^      void GetTstartTstop(braid_Real *tstart_ptr, braid_Real *tstop_ptr)$/;"	f	class:BraidStepStatus
GetTstop	xbraid/braid/braid.hpp	/^      void GetTstop(braid_Real *tstop_ptr)               { braid_StepStatusGetTstop(pstatus, tstop_ptr); }$/;"	f	class:BraidStepStatus
GetWarmRestart	xbraid/braid/braid.hpp	/^   braid_Int GetWarmRestart() { return _braid_CoreElt(core, warm_restart); };$/;"	f	class:BraidCore
GetWrapperTest	xbraid/braid/braid.hpp	/^      void GetWrapperTest(braid_Int *wtest_ptr) { braid_AccessStatusGetWrapperTest(astatus, wtest_ptr); }$/;"	f	class:BraidAccessStatus
H	xbraid/drivers/mfem_arnoldi.hpp	/^        DenseMatrix H;$/;"	m	class:Arnoldi
H0	include/hessianApprox.hpp	/^      MyReal   H0;            \/* Initial Hessian scaling factor *\/$/;"	m	class:L_BFGS
HYPRE_DIR	xbraid/drivers/Makefile	/^HYPRE_DIR = ..\/..\/hypre\/src\/hypre$/;"	m
HYPRE_DIR	xbraid/examples/Makefile	/^HYPRE_DIR = ..\/..\/hypre\/src\/hypre$/;"	m
HYPRE_FLAGS	xbraid/drivers/Makefile	/^HYPRE_FLAGS = -I$(HYPRE_DIR)\/include$/;"	m
HYPRE_FLAGS	xbraid/examples/Makefile	/^HYPRE_FLAGS = -I$(HYPRE_DIR)\/include$/;"	m
HYPRE_LIB	xbraid/drivers/Makefile	/^HYPRE_LIB = -L$(HYPRE_DIR)\/lib -lHYPRE$/;"	m
HYPRE_LIB	xbraid/examples/Makefile	/^HYPRE_LIB = -L$(HYPRE_DIR)\/lib -lHYPRE$/;"	m
HYPRE_LIB_FILE	xbraid/examples/Makefile	/^HYPRE_LIB_FILE = $(HYPRE_DIR)\/lib\/libHYPRE.a$/;"	m
Hessian	include/hessianApprox.hpp	/^      MyReal* Hessian;        \/* Storing the Hessian approximation (flattened: dimN*dimN) *\/$/;"	m	class:BFGS
HessianApprox	include/hessianApprox.hpp	/^class HessianApprox {$/;"	c
Hop	xbraid/drivers/mfem_arnoldi.hpp	/^        DenseMatrixTimeDependentOperator Hop;$/;"	m	class:Arnoldi
Hy	include/hessianApprox.hpp	/^      MyReal* Hy;$/;"	m	class:BFGS
IDENTITY	include/config.hpp	/^enum hessiantype{BFGS_SERIAL, LBFGS, IDENTITY};$/;"	e	enum:hessiantype
INC	Makefile	/^INC = -I$(INC_DIR) -I$(BRAID_INC_DIR)$/;"	m
INC_DIR	Makefile	/^INC_DIR   = include$/;"	m
INIT	xbraid/braid/_braid_tape.h	/^   INIT       = 2,$/;"	e	enum:_braid_Call_enum
Identity	include/hessianApprox.hpp	/^class Identity : public HessianApprox{$/;"	c
Init	xbraid/drivers/braid_mfem.hpp	/^int MFEMBraidApp::Init(double        t,$/;"	f	class:MFEMBraidApp
Init	xbraid/drivers/braid_mfem_block.hpp	/^int MFEMBraidApp::Init(double t, braid_Vector *u_ptr)$/;"	f	class:MFEMBraidApp
InitLevel	xbraid/drivers/braid_mfem.hpp	/^void MFEMBraidApp::InitLevel(int l)$/;"	f	class:MFEMBraidApp
InitLevel	xbraid/drivers/braid_mfem_block.hpp	/^void MFEMBraidApp::InitLevel(int l)$/;"	f	class:MFEMBraidApp
InitMultilevelApp	xbraid/drivers/braid_mfem.hpp	/^void MFEMBraidApp::InitMultilevelApp(ParMesh *pmesh, int pref, bool scoarsen)$/;"	f	class:MFEMBraidApp
InitMultilevelApp	xbraid/drivers/braid_mfem_block.hpp	/^void MFEMBraidApp::InitMultilevelApp(ParMesh *pmesh, int pref, bool scoarsen)$/;"	f	class:MFEMBraidApp
LBFGS	include/config.hpp	/^enum hessiantype{BFGS_SERIAL, LBFGS, IDENTITY};$/;"	e	enum:hessiantype
L_BFGS	include/hessianApprox.hpp	/^class L_BFGS : public HessianApprox {$/;"	c
Layer	include/layer.hpp	/^class Layer $/;"	c
LoadMeshAndRefine	xbraid/drivers/braid_mfem.hpp	/^ParMesh *BraidOptions::LoadMeshAndRefine(MPI_Comm comm_x)$/;"	f	class:BraidOptions
LoadMeshAndSerialRefine	xbraid/drivers/braid_mfem.hpp	/^Mesh *BraidOptions::LoadMeshAndSerialRefine()$/;"	f	class:BraidOptions
LoadMeshAndSerialRefine	xbraid/drivers/braid_mfem_block.hpp	/^Mesh *BraidOptions::LoadMeshAndSerialRefine()$/;"	f	class:BraidOptions
M	include/hessianApprox.hpp	/^      int M;                  \/* Length of the l-bfgs memory (stages) *\/$/;"	m	class:L_BFGS
MFEMBraidApp	xbraid/drivers/braid_mfem.hpp	/^MFEMBraidApp::MFEMBraidApp($/;"	f	class:MFEMBraidApp
MFEMBraidApp	xbraid/drivers/braid_mfem.hpp	/^class MFEMBraidApp : public BraidApp$/;"	c
MFEMBraidApp	xbraid/drivers/braid_mfem_block.hpp	/^MFEMBraidApp::MFEMBraidApp( MPI_Comm comm_t_, TimeDependentOperator *ode_, BlockVector *X0_,$/;"	f	class:MFEMBraidApp
MFEMBraidApp	xbraid/drivers/braid_mfem_block.hpp	/^MFEMBraidApp::MFEMBraidApp( MPI_Comm comm_t_, const int num_space_levels, double tstart_,$/;"	f	class:MFEMBraidApp
MFEMBraidApp	xbraid/drivers/braid_mfem_block.hpp	/^MFEMBraidApp::MFEMBraidApp(MPI_Comm comm_t_, double tstart_, double tstop_, int ntime_)$/;"	f	class:MFEMBraidApp
MFEMBraidApp	xbraid/drivers/braid_mfem_block.hpp	/^class MFEMBraidApp : public BraidApp$/;"	c
MFEM_CONFIG_MK	xbraid/drivers/Makefile	/^MFEM_CONFIG_MK = $(MFEM_DIR)\/config\/config.mk$/;"	m
MFEM_CONFIG_MK	xbraid/examples/Makefile	/^MFEM_CONFIG_MK = $(MFEM_DIR)\/config\/config.mk$/;"	m
MFEM_DIR	xbraid/drivers/Makefile	/^MFEM_DIR = ..\/..\/mfem$/;"	m
MFEM_DIR	xbraid/examples/Makefile	/^MFEM_DIR = ..\/..\/mfem$/;"	m
MFEM_INTERFACE	xbraid/drivers/Makefile	/^MFEM_INTERFACE = .\/braid_mfem.hpp .\/braid_mfem_block.hpp ..\/braid\/braid.hpp$/;"	m
MFEM_LIB_FILE	xbraid/drivers/Makefile	/^MFEM_LIB_FILE = mfem_is_not_built$/;"	m
MFEM_LIB_FILE	xbraid/examples/Makefile	/^MFEM_LIB_FILE = mfem_is_not_built$/;"	m
MPI_ANY_SOURCE	xbraid/braid/mpistubs.h	65;"	d
MPI_ANY_TAG	xbraid/braid/mpistubs.h	66;"	d
MPI_Aint	xbraid/braid/mpistubs.h	/^typedef int  MPI_Aint;$/;"	t
MPI_BOTTOM	xbraid/braid/mpistubs.h	46;"	d
MPI_BYTE	xbraid/braid/mpistubs.h	52;"	d
MPI_CHAR	xbraid/braid/mpistubs.h	50;"	d
MPI_COMM_NULL	xbraid/braid/mpistubs.h	44;"	d
MPI_COMM_WORLD	xbraid/braid/mpistubs.h	43;"	d
MPI_COMPLEX	xbraid/braid/mpistubs.h	54;"	d
MPI_Comm	xbraid/braid/braid.h	/^typedef int MPI_Comm;$/;"	t
MPI_DOUBLE	xbraid/braid/mpistubs.h	48;"	d
MPI_Datatype	xbraid/braid/mpistubs.h	/^typedef int MPI_Datatype;$/;"	t
MPI_Group	xbraid/braid/mpistubs.h	/^typedef int MPI_Group;$/;"	t
MPI_INT	xbraid/braid/mpistubs.h	49;"	d
MPI_LONG	xbraid/braid/mpistubs.h	51;"	d
MPI_LOR	xbraid/braid/mpistubs.h	59;"	d
MPI_MAX	xbraid/braid/mpistubs.h	58;"	d
MPI_MIN	xbraid/braid/mpistubs.h	57;"	d
MPI_MyReal	include/defs.hpp	11;"	d
MPI_Op	xbraid/braid/mpistubs.h	/^typedef int  MPI_Op;$/;"	t
MPI_REAL	xbraid/braid/mpistubs.h	53;"	d
MPI_REQUEST_NULL	xbraid/braid/mpistubs.h	64;"	d
MPI_Request	xbraid/braid/mpistubs.h	/^typedef int MPI_Request;$/;"	t
MPI_SOURCE	xbraid/braid/mpistubs.h	/^   int MPI_SOURCE;$/;"	m	struct:__anon1
MPI_STATUSES_IGNORE	xbraid/braid/mpistubs.h	61;"	d
MPI_SUCCESS	xbraid/braid/mpistubs.h	60;"	d
MPI_SUM	xbraid/braid/mpistubs.h	56;"	d
MPI_Status	xbraid/braid/mpistubs.h	/^} MPI_Status;$/;"	t	typeref:struct:__anon1
MPI_TAG	xbraid/braid/mpistubs.h	/^   int MPI_TAG;$/;"	m	struct:__anon1
MPI_UNDEFINED	xbraid/braid/mpistubs.h	63;"	d
MPIcomm	include/hessianApprox.hpp	/^      MPI_Comm MPIcomm;       \/* MPI communicator for parallel L-BFGS updates *\/$/;"	m	class:HessianApprox
MPIrank	include/dataset.hpp	/^      int MPIrank;           \/* Processors rank *\/$/;"	m	class:DataSet
MPIsize	include/dataset.hpp	/^      int MPIsize;           \/* Size of the global communicator *\/$/;"	m	class:DataSet
Mult	xbraid/drivers/mfem_arnoldi.hpp	/^        virtual void Mult(const Vector &x, Vector &y) const$/;"	f	class:DenseMatrixTimeDependentOperator
MyReal	include/defs.hpp	/^typedef double MyReal;$/;"	t
Network	include/network.hpp	/^class Network$/;"	c
OBJECTIVET	xbraid/braid/_braid_tape.h	/^   OBJECTIVET = 9$/;"	e	enum:_braid_Call_enum
OBJ_FILES	Makefile	/^OBJ_FILES  = $(patsubst $(SRC_DIR)\/%.cpp,$(BUILD_DIR)\/%.o,$(SRC_FILES))$/;"	m
ONEOVERK	include/config.hpp	/^enum stepsizetype{FIXED, BACKTRACKINGLS, ONEOVERK};$/;"	e	enum:stepsizetype
OPENCONV	include/layer.hpp	/^      enum layertype{OPENZERO=0, OPENDENSE=1, DENSE=2, CLASSIFICATION=3, OPENCONV=4, OPENCONVMNIST=5, CONVOLUTION=6};$/;"	e	enum:Layer::layertype
OPENCONVMNIST	include/layer.hpp	/^      enum layertype{OPENZERO=0, OPENDENSE=1, DENSE=2, CLASSIFICATION=3, OPENCONV=4, OPENCONVMNIST=5, CONVOLUTION=6};$/;"	e	enum:Layer::layertype
OPENDENSE	include/layer.hpp	/^      enum layertype{OPENZERO=0, OPENDENSE=1, DENSE=2, CLASSIFICATION=3, OPENCONV=4, OPENCONVMNIST=5, CONVOLUTION=6};$/;"	e	enum:Layer::layertype
OPENZERO	include/layer.hpp	/^      enum layertype{OPENZERO=0, OPENDENSE=1, DENSE=2, CLASSIFICATION=3, OPENCONV=4, OPENCONVMNIST=5, CONVOLUTION=6};$/;"	e	enum:Layer::layertype
OpenConvLayer	include/layer.hpp	/^class OpenConvLayer : public Layer {$/;"	c
OpenConvLayerMNIST	include/layer.hpp	/^class OpenConvLayerMNIST : public OpenConvLayer {$/;"	c
OpenDenseLayer	include/layer.hpp	/^class OpenDenseLayer : public DenseLayer {$/;"	c
OpenExpandZero	include/layer.hpp	/^class OpenExpandZero : public Layer $/;"	c
OrderedBunch	pythonutil/ordered_bunch.py	/^class OrderedBunch(OrderedDict):$/;"	c
OrderedDict	pythonutil/ordered_dict.py	/^class OrderedDict(dict):$/;"	c
P	xbraid/drivers/braid_mfem.hpp	/^   Array<const SparseMatrix *>    P;  \/\/ local prolongation matrices, l+1 --> l$/;"	m	class:MFEMBraidApp
P	xbraid/drivers/braid_mfem_block.hpp	/^    Array<const SparseMatrix *>     P;  \/\/ local interpolation matrices, l --> l+1$/;"	m	class:MFEMBraidApp
Print	xbraid/drivers/braid_mfem.hpp	/^void SpaceTimeMeshInfo::Print(MPI_Comm comm)$/;"	f	class:SpaceTimeMeshInfo
Print	xbraid/drivers/braid_mfem_block.hpp	/^void SpaceTimeMeshInfo::Print(MPI_Comm comm)$/;"	f	class:SpaceTimeMeshInfo
RELU	include/config.hpp	/^enum activation{TANH, RELU, SMRELU};  $/;"	e	enum:activation
Refine	xbraid/braid/braid.hpp	/^   virtual braid_Int Refine(braid_Vector           cu_,$/;"	f	class:BraidApp
Refine	xbraid/drivers/braid_mfem.hpp	/^int MFEMBraidApp::Refine(braid_Vector   cu_,$/;"	f	class:MFEMBraidApp
Refine	xbraid/drivers/braid_mfem_block.hpp	/^int MFEMBraidApp::Refine(braid_Vector cu_, braid_Vector  *fu_ptr, BraidCoarsenRefStatus &status)$/;"	f	class:MFEMBraidApp
Reinitialize	xbraid/drivers/braid_mfem.hpp	/^void SpaceTimeMeshInfo::Reinitialize(int _max_levels)$/;"	f	class:SpaceTimeMeshInfo
Reinitialize	xbraid/drivers/braid_mfem_block.hpp	/^void SpaceTimeMeshInfo::Reinitialize(int _max_levels)$/;"	f	class:SpaceTimeMeshInfo
Residual	xbraid/drivers/braid_mfem.hpp	/^   virtual int Residual(braid_Vector     u_,$/;"	f	class:MFEMBraidApp
Residual	xbraid/drivers/braid_mfem_block.hpp	/^int MFEMBraidApp::Residual(braid_Vector u_, braid_Vector r_, BraidStepStatus &pstatus)$/;"	f	class:MFEMBraidApp
SEQFLAGS	xbraid/braid/Makefile	/^	SEQFLAGS = $/;"	m
SEQFLAGS	xbraid/braid/Makefile	/^	SEQFLAGS = -Dbraid_SEQUENTIAL$/;"	m
SMRELU	include/config.hpp	/^enum activation{TANH, RELU, SMRELU};  $/;"	e	enum:activation
SRC_DIR	Makefile	/^SRC_DIR   = src$/;"	m
SRC_FILES	Makefile	/^SRC_FILES  = $(wildcard $(SRC_DIR)\/*.cpp)$/;"	m
STEP	xbraid/braid/_braid_tape.h	/^   STEP       = 1,$/;"	e	enum:_braid_Call_enum
STOCHASTIC	include/config.hpp	/^enum batchtype{DETERMINISTIC, STOCHASTIC};$/;"	e	enum:batchtype
SUM	xbraid/braid/_braid_tape.h	/^   SUM        = 5,$/;"	e	enum:_braid_Call_enum
SetAbsTol	xbraid/braid/braid.hpp	/^   void SetAbsTol(braid_Real tol) { braid_SetAbsTol(core, tol); }$/;"	f	class:BraidCore
SetAccessLevel	xbraid/braid/braid.hpp	/^   void SetAccessLevel(braid_Int access_level) { braid_SetAccessLevel(core, access_level); }$/;"	f	class:BraidCore
SetAggCFactor	xbraid/braid/braid.hpp	/^   void SetAggCFactor(braid_Int cfactor0)$/;"	f	class:BraidCore
SetBraidCoreOptions	xbraid/drivers/braid_mfem.hpp	/^void BraidOptions::SetBraidCoreOptions(BraidCore &core)$/;"	f	class:BraidOptions
SetBraidCoreOptions	xbraid/drivers/braid_mfem_block.hpp	/^void BraidOptions::SetBraidCoreOptions(BraidCore &core)$/;"	f	class:BraidOptions
SetCFactor	xbraid/braid/braid.hpp	/^   void SetCFactor(braid_Int level, braid_Int cfactor)$/;"	f	class:BraidCore
SetExactSolution	xbraid/drivers/braid_mfem.hpp	/^   void SetExactSolution(Coefficient *exsol) { exact_sol = exsol; }$/;"	f	class:MFEMBraidApp
SetExactSolution	xbraid/drivers/braid_mfem_block.hpp	/^    void SetExactSolution(Coefficient *exsol) { exact_sol = exsol; }$/;"	f	class:MFEMBraidApp
SetFMG	xbraid/braid/braid.hpp	/^   void SetFMG() { braid_SetFMG(core); }$/;"	f	class:BraidCore
SetInitialCondition	xbraid/drivers/braid_mfem.hpp	/^   void SetInitialCondition(HypreParVector *_X0) { X0 = _X0; }$/;"	f	class:MFEMBraidApp
SetInitialCondition	xbraid/drivers/braid_mfem_block.hpp	/^    void SetInitialCondition(BlockVector *_X0) { X0 = _X0; }$/;"	f	class:MFEMBraidApp
SetMaxIter	xbraid/braid/braid.hpp	/^   void SetMaxIter(braid_Int max_iter) { braid_SetMaxIter(core, max_iter); }$/;"	f	class:BraidCore
SetMaxLevels	xbraid/braid/braid.hpp	/^   void SetMaxLevels(braid_Int max_levels) { braid_SetMaxLevels(core, max_levels); }$/;"	f	class:BraidCore
SetMaxRefinements	xbraid/braid/braid.hpp	/^   void SetMaxRefinements(braid_Int max_refinements) {braid_SetMaxRefinements(core, max_refinements);}$/;"	f	class:BraidCore
SetMinCoarse	xbraid/braid/braid.hpp	/^   void SetMinCoarse(braid_Int min_coarse) { braid_SetMinCoarse(core, min_coarse); }$/;"	f	class:BraidCore
SetNFMG	xbraid/braid/braid.hpp	/^   void SetNFMG(braid_Int k) { braid_SetNFMG(core, k); }$/;"	f	class:BraidCore
SetNFMGVcyc	xbraid/braid/braid.hpp	/^   void SetNFMGVcyc(braid_Int nfmg_Vcyc) { braid_SetNFMGVcyc(core, nfmg_Vcyc); }$/;"	f	class:BraidCore
SetNRelax	xbraid/braid/braid.hpp	/^   void SetNRelax(braid_Int level, braid_Int nrelax)$/;"	f	class:BraidCore
SetOldFineTolx	xbraid/braid/braid.hpp	/^      void SetOldFineTolx(braid_Real old_fine_tolx)      { braid_StepStatusSetOldFineTolx(pstatus, old_fine_tolx); }$/;"	f	class:BraidStepStatus
SetOperator	xbraid/drivers/mfem_arnoldi.hpp	/^        void SetOperator(Operator &A_)$/;"	f	class:Arnoldi
SetPrintFile	xbraid/braid/braid.hpp	/^   void SetPrintFile(const char *printfile_name) { braid_SetPrintFile(core, printfile_name); }$/;"	f	class:BraidCore
SetPrintLevel	xbraid/braid/braid.hpp	/^   void SetPrintLevel(braid_Int print_level) { braid_SetPrintLevel(core, print_level); }$/;"	f	class:BraidCore
SetRFactor	xbraid/braid/braid.hpp	/^      void SetRFactor(braid_Int rfactor)                 { braid_StepStatusSetRFactor(pstatus, rfactor); }$/;"	f	class:BraidStepStatus
SetRSpace	xbraid/braid/braid.hpp	/^      void SetRSpace(braid_Int rspace)                   { braid_StepStatusSetRSpace(pstatus, rspace); }$/;"	f	class:BraidStepStatus
SetRandomInitVectors	xbraid/drivers/braid_mfem.hpp	/^   void SetRandomInitVectors(unsigned seed)$/;"	f	class:MFEMBraidApp
SetRefine	xbraid/braid/braid.hpp	/^   void SetRefine(braid_Int refine) {braid_SetRefine(core, refine);}$/;"	f	class:BraidCore
SetRelTol	xbraid/braid/braid.hpp	/^   void SetRelTol(braid_Real tol) { braid_SetRelTol(core, tol); }$/;"	f	class:BraidCore
SetResidual	xbraid/braid/braid.hpp	/^   void SetResidual() { braid_SetResidual(core, _BraidAppResidual); }$/;"	f	class:BraidCore
SetRevertedRanks	xbraid/braid/braid.hpp	/^   void SetRevertedRanks(braid_Int reverted_ranks) { braid_SetRevertedRanks(core, reverted_ranks); }$/;"	f	class:BraidCore
SetRow	xbraid/drivers/braid_mfem.hpp	/^void SpaceTimeMeshInfo::SetRow(int braid_level, int vec_level, ParMesh * pmesh, double dt)$/;"	f	class:SpaceTimeMeshInfo
SetRow	xbraid/drivers/braid_mfem_block.hpp	/^void SpaceTimeMeshInfo::SetRow(int braid_level, int vec_level, ParMesh * pmesh, double dt)$/;"	f	class:SpaceTimeMeshInfo
SetSeqSoln	xbraid/braid/braid.hpp	/^   void SetSeqSoln(braid_Int use_seq_soln) { braid_SetSeqSoln(core, use_seq_soln); }$/;"	f	class:BraidCore
SetSize	xbraid/braid/braid.hpp	/^      void SetSize( braid_Int size ) { braid_BufferStatusSetSize( bstatus, size ); }$/;"	f	class:BraidBufferStatus
SetSkip	xbraid/braid/braid.hpp	/^   void SetSkip(braid_Int skip) { braid_SetSkip(core, skip); }$/;"	f	class:BraidCore
SetSpaceLevel	xbraid/drivers/braid_mfem.hpp	/^void MFEMBraidApp::SetSpaceLevel(int l, TimeDependentOperator *ode_l,$/;"	f	class:MFEMBraidApp
SetSpaceLevel	xbraid/drivers/braid_mfem_block.hpp	/^void MFEMBraidApp::SetSpaceLevel(int l, TimeDependentOperator *ode_l, ODESolver *solver_l, $/;"	f	class:MFEMBraidApp
SetSpatialCoarsenAndRefine	xbraid/braid/braid.hpp	/^   void SetSpatialCoarsenAndRefine()$/;"	f	class:BraidCore
SetStorage	xbraid/braid/braid.hpp	/^   void SetStorage(braid_Int storage) { braid_SetStorage(core, storage); }$/;"	f	class:BraidCore
SetTemporalNorm	xbraid/braid/braid.hpp	/^   void SetTemporalNorm(braid_Int tnorm) { braid_SetTemporalNorm(core, tnorm); }$/;"	f	class:BraidCore
SetTightFineTolx	xbraid/braid/braid.hpp	/^      void SetTightFineTolx(braid_Int tight_fine_tolx)   { braid_StepStatusSetTightFineTolx(pstatus, tight_fine_tolx); }$/;"	f	class:BraidStepStatus
SetVisHostAndPort	xbraid/drivers/braid_mfem.hpp	/^void MFEMBraidApp::SetVisHostAndPort(const char *vh, int vp)$/;"	f	class:MFEMBraidApp
SetVisHostAndPort	xbraid/drivers/braid_mfem_block.hpp	/^void MFEMBraidApp::SetVisHostAndPort(const char *vh, int vp)$/;"	f	class:MFEMBraidApp
SetVisSampling	xbraid/drivers/braid_mfem.hpp	/^   void SetVisSampling(int time_steps, int braid_steps)$/;"	f	class:MFEMBraidApp
SetVisSampling	xbraid/drivers/braid_mfem_block.hpp	/^    void SetVisSampling(int time_steps, int braid_steps)$/;"	f	class:MFEMBraidApp
SetVisScreenshots	xbraid/drivers/braid_mfem.hpp	/^   void SetVisScreenshots(bool ss) { vis_screenshots = ss; }$/;"	f	class:MFEMBraidApp
SetVisScreenshots	xbraid/drivers/braid_mfem_block.hpp	/^    void SetVisScreenshots(bool ss) { vis_screenshots = ss; }$/;"	f	class:MFEMBraidApp
SpaceTimeMeshInfo	xbraid/drivers/braid_mfem.hpp	/^   SpaceTimeMeshInfo(int _max_levels) :$/;"	f	class:SpaceTimeMeshInfo
SpaceTimeMeshInfo	xbraid/drivers/braid_mfem.hpp	/^class SpaceTimeMeshInfo$/;"	c
SpaceTimeMeshInfo	xbraid/drivers/braid_mfem_block.hpp	/^     SpaceTimeMeshInfo(int _max_levels) : $/;"	f	class:SpaceTimeMeshInfo
SpaceTimeMeshInfo	xbraid/drivers/braid_mfem_block.hpp	/^class SpaceTimeMeshInfo$/;"	c
SpatialNorm	xbraid/drivers/braid_mfem.hpp	/^int MFEMBraidApp::SpatialNorm(braid_Vector  u_,$/;"	f	class:MFEMBraidApp
SpatialNorm	xbraid/drivers/braid_mfem_block.hpp	/^int MFEMBraidApp::SpatialNorm(braid_Vector  u_, double *norm_ptr)$/;"	f	class:MFEMBraidApp
SplitCommworld	xbraid/braid/braid.hpp	/^   void SplitCommworld(const MPI_Comm  *comm_world,$/;"	f	class:BraidUtil
Step	xbraid/drivers/braid_mfem.hpp	/^int MFEMBraidApp::Step(braid_Vector    u_,$/;"	f	class:MFEMBraidApp
Step	xbraid/drivers/braid_mfem_block.hpp	/^int MFEMBraidApp::Step(braid_Vector  u_, braid_Vector ustop_, braid_Vector fstop_, BraidStepStatus &pstatus)$/;"	f	class:MFEMBraidApp
StepStatusGetTol	xbraid/braid/braid.hpp	/^      void StepStatusGetTol(braid_Real *tol_ptr)         { braid_StepStatusGetTol(pstatus, tol_ptr); }$/;"	f	class:BraidStepStatus
Sum	xbraid/drivers/braid_mfem.hpp	/^int MFEMBraidApp::Sum(double       alpha,$/;"	f	class:MFEMBraidApp
Sum	xbraid/drivers/braid_mfem_block.hpp	/^int MFEMBraidApp::Sum(double alpha, braid_Vector a_, double beta, braid_Vector b_)$/;"	f	class:MFEMBraidApp
T	include/config.hpp	/^      MyReal T;$/;"	m	class:Config
TABLE OF CONTENTS	xbraid/docs/developer_manual_header.tex	/^\\tableofcontents$/;"	s
TABLE OF CONTENTS	xbraid/docs/user_manual_header.tex	/^\\tableofcontents$/;"	s
TANH	include/config.hpp	/^enum activation{TANH, RELU, SMRELU};  $/;"	e	enum:activation
TestAll	xbraid/braid/braid.hpp	/^   braid_Int TestAll(BraidApp   *app,$/;"	f	class:BraidUtil
TestBuf	xbraid/braid/braid.hpp	/^   braid_Int TestBuf(BraidApp   *app,$/;"	f	class:BraidUtil
TestClone	xbraid/braid/braid.hpp	/^   void TestClone(BraidApp   *app,$/;"	f	class:BraidUtil
TestCoarsenRefine	xbraid/braid/braid.hpp	/^   braid_Int TestCoarsenRefine(BraidApp   *app,$/;"	f	class:BraidUtil
TestInitAccess	xbraid/braid/braid.hpp	/^   void TestInitAccess(BraidApp   *app,$/;"	f	class:BraidUtil
TestResidual	xbraid/braid/braid.hpp	/^   braid_Int TestResidual(BraidApp   *app,$/;"	f	class:BraidUtil
TestSpatialNorm	xbraid/braid/braid.hpp	/^   braid_Int TestSpatialNorm(BraidApp   *app,$/;"	f	class:BraidUtil
TestSum	xbraid/braid/braid.hpp	/^   void TestSum(BraidApp   *app,$/;"	f	class:BraidUtil
TrueDofsToLDofs	xbraid/drivers/braid_mfem_block.hpp	/^void TrueDofsToLDofs(const Vector &u, ParGridFunction &v)$/;"	f	namespace:mfem
V	xbraid/drivers/mfem_arnoldi.hpp	/^        Vector *V;$/;"	m	class:Arnoldi
X0	xbraid/drivers/braid_mfem.hpp	/^   HypreParVector *X0;    \/\/ Initial condition (at the finest level 0)$/;"	m	class:MFEMBraidApp
X0	xbraid/drivers/braid_mfem_block.hpp	/^    BlockVector *X0;     \/\/ Initial condition (at the finest level 0)$/;"	m	class:MFEMBraidApp
_BraidAppAccess	xbraid/braid/braid.hpp	/^static braid_Int _BraidAppAccess(braid_App          _app,$/;"	f
_BraidAppBufPack	xbraid/braid/braid.hpp	/^static braid_Int _BraidAppBufPack(braid_App     _app,$/;"	f
_BraidAppBufSize	xbraid/braid/braid.hpp	/^static braid_Int _BraidAppBufSize(braid_App  _app,$/;"	f
_BraidAppBufUnpack	xbraid/braid/braid.hpp	/^static braid_Int _BraidAppBufUnpack(braid_App     _app,$/;"	f
_BraidAppClone	xbraid/braid/braid.hpp	/^static braid_Int _BraidAppClone(braid_App     _app,$/;"	f
_BraidAppCoarsen	xbraid/braid/braid.hpp	/^static braid_Int _BraidAppCoarsen(braid_App               _app,$/;"	f
_BraidAppFree	xbraid/braid/braid.hpp	/^static braid_Int _BraidAppFree(braid_App    _app,$/;"	f
_BraidAppInit	xbraid/braid/braid.hpp	/^static braid_Int _BraidAppInit(braid_App     _app,$/;"	f
_BraidAppRefine	xbraid/braid/braid.hpp	/^static braid_Int _BraidAppRefine(braid_App               _app,$/;"	f
_BraidAppResidual	xbraid/braid/braid.hpp	/^static braid_Int _BraidAppResidual(braid_App     _app,$/;"	f
_BraidAppSpatialNorm	xbraid/braid/braid.hpp	/^static braid_Int _BraidAppSpatialNorm(braid_App     _app,$/;"	f
_BraidAppStep	xbraid/braid/braid.hpp	/^static braid_Int _BraidAppStep(braid_App       _app,$/;"	f
_BraidAppSum	xbraid/braid/braid.hpp	/^static braid_Int _BraidAppSum(braid_App    _app,$/;"	f
__contains__	pythonutil/ordered_bunch.py	/^    def __contains__(self, k):$/;"	m	class:OrderedBunch	file:
__delattr__	pythonutil/ordered_bunch.py	/^    def __delattr__(self, k):$/;"	m	class:OrderedBunch	file:
__delitem__	pythonutil/ordered_dict.py	/^    def __delitem__(self, key, dict_delitem=dict.__delitem__):$/;"	m	class:OrderedDict	file:
__eq__	pythonutil/config.py	/^    def __eq__(self,konfig):$/;"	m	class:Config	file:
__eq__	pythonutil/ordered_dict.py	/^    def __eq__(self, other):$/;"	m	class:OrderedDict	file:
__getattr__	pythonutil/config.py	/^    def __getattr__(self,k):$/;"	m	class:Config	file:
__getattr__	pythonutil/ordered_bunch.py	/^    def __getattr__(self, k):$/;"	m	class:OrderedBunch	file:
__getitem__	pythonutil/config.py	/^    def __getitem__(self,k):$/;"	m	class:Config	file:
__init__	pythonutil/config.py	/^    def __init__(self,*args,**kwarg):$/;"	m	class:Config
__init__	pythonutil/ordered_bunch.py	/^    def __init__(self,*args,**kwarg):$/;"	m	class:OrderedBunch
__init__	pythonutil/ordered_dict.py	/^    def __init__(self, *args, **kwds):$/;"	m	class:OrderedDict
__init__	pythonutil/switch.py	/^    def __init__(self, value):$/;"	m	class:switch
__iter__	pythonutil/ordered_dict.py	/^    def __iter__(self):$/;"	m	class:OrderedDict	file:
__iter__	pythonutil/switch.py	/^    def __iter__(self):$/;"	m	class:switch	file:
__marker	pythonutil/ordered_dict.py	/^    __marker = object()$/;"	v	class:OrderedDict
__ne__	pythonutil/config.py	/^    def __ne__(self,konfig):$/;"	m	class:Config	file:
__ne__	pythonutil/ordered_dict.py	/^    def __ne__(self, other):$/;"	m	class:OrderedDict	file:
__reduce__	pythonutil/ordered_dict.py	/^    def __reduce__(self):$/;"	m	class:OrderedDict	file:
__repr__	pythonutil/config.py	/^    def __repr__(self):$/;"	m	class:Config	file:
__repr__	pythonutil/ordered_bunch.py	/^    def __repr__(self):$/;"	m	class:OrderedBunch	file:
__repr__	pythonutil/ordered_dict.py	/^    def __repr__(self, _repr_running={}):$/;"	m	class:OrderedDict	file:
__reversed__	pythonutil/ordered_dict.py	/^    def __reversed__(self):$/;"	m	class:OrderedDict	file:
__setattr__	pythonutil/ordered_bunch.py	/^    def __setattr__(self, k, v):$/;"	m	class:OrderedBunch	file:
__setitem__	pythonutil/ordered_dict.py	/^    def __setitem__(self, key, value, dict_setitem=dict.__setitem__):$/;"	m	class:OrderedDict	file:
__str__	pythonutil/config.py	/^    def __str__(self):$/;"	m	class:Config	file:
__str__	pythonutil/ordered_bunch.py	/^    def __str__(self):$/;"	m	class:OrderedBunch	file:
__update	pythonutil/ordered_dict.py	/^    __update = update  # let subclasses override update without breaking __init__$/;"	v	class:OrderedDict
_braid_AccessStatus_struct	xbraid/braid/_braid_status.h	/^struct _braid_AccessStatus_struct$/;"	s
_braid_Action	xbraid/braid/_braid_tape.h	/^} _braid_Action;$/;"	t	typeref:struct:_braid_Action_struct
_braid_Action_struct	xbraid/braid/_braid_tape.h	/^typedef struct _braid_Action_struct$/;"	s
_braid_BaseVector_struct	xbraid/braid/_braid.h	/^struct _braid_BaseVector_struct$/;"	s
_braid_BufferStatus_struct	xbraid/braid/_braid_status.h	/^struct _braid_BufferStatus_struct$/;"	s
_braid_CTAlloc	xbraid/braid/braid_defs.h	96;"	d
_braid_Call	xbraid/braid/_braid_tape.h	/^} _braid_Call;$/;"	t	typeref:enum:_braid_Call_enum
_braid_Call_enum	xbraid/braid/_braid_tape.h	/^typedef enum _braid_Call_enum$/;"	g
_braid_CoarsenRefStatus_struct	xbraid/braid/_braid_status.h	/^struct _braid_CoarsenRefStatus_struct$/;"	s
_braid_CommHandle	xbraid/braid/_braid.h	/^} _braid_CommHandle;$/;"	t	typeref:struct:__anon2
_braid_CommHandleElt	xbraid/braid/_braid.h	307;"	d
_braid_Core	xbraid/braid/_braid.h	/^} _braid_Core;$/;"	t	typeref:struct:_braid_Core_struct
_braid_CoreElt	xbraid/braid/_braid.h	317;"	d
_braid_CoreFcn	xbraid/braid/_braid.h	322;"	d
_braid_Core_struct	xbraid/braid/_braid.h	/^typedef struct _braid_Core_struct$/;"	s
_braid_Error	xbraid/braid/braid_defs.h	80;"	d
_braid_ErrorInArg	xbraid/braid/braid_defs.h	81;"	d
_braid_Grid	xbraid/braid/_braid.h	/^} _braid_Grid;$/;"	t	typeref:struct:__anon3
_braid_GridElt	xbraid/braid/_braid.h	312;"	d
_braid_HEADER	xbraid/braid/_braid.h	32;"	d
_braid_IsCPoint	xbraid/braid/_braid.h	360;"	d
_braid_IsFPoint	xbraid/braid/_braid.h	354;"	d
_braid_MapCoarseToFine	xbraid/braid/_braid.h	348;"	d
_braid_MapFineToCoarse	xbraid/braid/_braid.h	341;"	d
_braid_NextCPoint	xbraid/braid/_braid.h	366;"	d
_braid_ObjectiveStatus_struct	xbraid/braid/_braid_status.h	/^struct _braid_ObjectiveStatus_struct$/;"	s
_braid_Optimization_struct	xbraid/braid/_braid.h	/^struct _braid_Optimization_struct$/;"	s
_braid_PriorCPoint	xbraid/braid/_braid.h	372;"	d
_braid_Status	xbraid/braid/_braid_status.h	/^typedef struct _braid_Status_struct _braid_Status;$/;"	t	typeref:struct:_braid_Status_struct
_braid_StatusElt	xbraid/braid/_braid_status.h	84;"	d
_braid_Status_struct	xbraid/braid/_braid_status.h	/^struct _braid_Status_struct$/;"	s
_braid_StepStatus_struct	xbraid/braid/_braid_status.h	/^struct _braid_StepStatus_struct$/;"	s
_braid_TAlloc	xbraid/braid/braid_defs.h	90;"	d
_braid_TFree	xbraid/braid/braid_defs.h	108;"	d
_braid_TReAlloc	xbraid/braid/braid_defs.h	102;"	d
_braid_Tape	xbraid/braid/_braid_tape.h	/^} _braid_Tape;$/;"	t	typeref:struct:_braid_tape_struct
_braid_VectorBar_struct	xbraid/braid/_braid.h	/^struct _braid_VectorBar_struct$/;"	s
_braid_base_HEADER	xbraid/braid/_braid_base.h	40;"	d
_braid_max	xbraid/braid/braid_defs.h	116;"	d
_braid_min	xbraid/braid/braid_defs.h	119;"	d
_braid_status_HEADER	xbraid/braid/_braid_status.h	31;"	d
_braid_tape_struct	xbraid/braid/_braid_tape.h	/^typedef struct _braid_tape_struct$/;"	s
_filename	pythonutil/config.py	/^    _filename = 'config.cfg'$/;"	v	class:Config
_initialized	pythonutil/ordered_bunch.py	/^    _initialized = False$/;"	v	class:OrderedBunch
a	xbraid/misc/user_utils/cycleplot.py	/^         a = data[:,4].min()$/;"	v
access	xbraid/braid/_braid.h	/^   braid_PtFcnAccess      access;           \/**< user access function to XBraid and current vector *\/$/;"	m	struct:_braid_Core_struct
access_level	xbraid/braid/_braid.h	/^   braid_Int              access_level;     \/**< determines how often to call the user's access routine *\/ $/;"	m	struct:_braid_Core_struct
access_level	xbraid/drivers/braid_mfem.hpp	/^   int    access_level;$/;"	m	struct:BraidOptions
access_level	xbraid/drivers/braid_mfem_block.hpp	/^    int  access_level;$/;"	m	struct:BraidOptions
access_level	xbraid/examples/ex-01-expanded-f.f90	/^   integer min_coarse, print_level, access_level,/;"	v	program:ex01_f90
accuracy	include/network.hpp	/^      MyReal  accuracy;             \/* Accuracy of the network prediction (percentage of successfully predicted classes) *\/$/;"	m	class:Network
actionTape	xbraid/braid/_braid.h	/^   _braid_Tape*          actionTape;         \/**< tape storing the actions while recording *\/$/;"	m	struct:_braid_Core_struct
activ	include/layer.hpp	/^      int     activ;                       \/* Activaation function (enum element) *\/$/;"	m	class:Layer
activation	include/config.hpp	/^      int    activation;$/;"	m	class:Config
activation	include/config.hpp	/^enum activation{TANH, RELU, SMRELU};  $/;"	g
adjoint	xbraid/braid/_braid.h	/^   braid_Int              adjoint;           \/**< determines if adjoint run is performed (1) or not (0) *\/$/;"	m	struct:_braid_Core_struct
adjoints	xbraid/braid/_braid.h	/^   braid_Vector    *adjoints;         \/**< vector for the adjoint variables *\/$/;"	m	struct:_braid_Optimization_struct
app	xbraid/braid/_braid.h	/^   braid_App              app;              \/**< application data for the user *\/$/;"	m	struct:_braid_Core_struct
app	xbraid/examples/ex-01-expanded-f.f90	/^   type(my_app)/;"	v	program:ex01_f90
arg	xbraid/examples/ex-01-expanded-f.f90	/^   character (len = 255) arg$/;"	v	program:ex01_f90
args	testing/testing.py	/^args = parser.parse_args()$/;"	v
assemble_batch_script	pythonutil/batch_job.py	/^def assemble_batch_script(name, run_command, args):$/;"	f
astatus	xbraid/braid/braid.hpp	/^      braid_AccessStatus astatus;$/;"	m	class:BraidAccessStatus
availIDs	include/dataset.hpp	/^      int* availIDs;          \/* Auxilliary: holding available batchIDs when generating a batch *\/$/;"	m	class:DataSet
ax2	xbraid/misc/user_utils/cycleplot.py	/^         ax2 = ax.twinx()$/;"	v
bar	xbraid/braid/_braid.h	/^   braid_VectorBar bar;             \/**< holds the bar vector (shared pointer implementation) *\/$/;"	m	struct:_braid_BaseVector_struct
barTape	xbraid/braid/_braid.h	/^   _braid_Tape*          barTape;            \/**< tape storing intermediate AD-bar variables while recording *\/$/;"	m	struct:_braid_Core_struct
batchIDs	include/dataset.hpp	/^      int *batchIDs;        \/* Array of batch indicees *\/$/;"	m	class:DataSet
batch_args_mapping	pythonutil/batch_job.py	/^batch_args_mapping = batch_args_mapping_slurm$/;"	v
batch_args_mapping_slurm	pythonutil/batch_job.py	/^batch_args_mapping_slurm = {"NAME"  : "--job-name",$/;"	v
batch_type	include/config.hpp	/^      int    batch_type;$/;"	m	class:Config
batchtype	include/config.hpp	/^enum batchtype{DETERMINISTIC, STOCHASTIC};$/;"	g
bias	include/layer.hpp	/^      MyReal* bias;                        \/* Bias *\/$/;"	m	class:Layer
bias_bar	include/layer.hpp	/^      MyReal* bias_bar;                    \/* Derivative of bias *\/$/;"	m	class:Layer
braidCall	xbraid/braid/_braid_tape.h	/^   _braid_Call       braidCall;        \/**< type of the user routine *\/$/;"	m	struct:_braid_Action_struct
braid_ASCaller_FAccess	xbraid/braid/braid_status.h	525;"	d
braid_ASCaller_FInterp	xbraid/braid/braid_status.h	519;"	d
braid_ASCaller_FRefine	xbraid/braid/braid_status.h	523;"	d
braid_ASCaller_FRestrict	xbraid/braid/braid_status.h	521;"	d
braid_AccessStatus	xbraid/braid/braid_status.h	/^typedef struct _braid_AccessStatus_struct *braid_AccessStatus;$/;"	t	typeref:struct:_braid_AccessStatus_struct
braid_Access_F90	xbraid/examples/ex-01-expanded-f.f90	/^subroutine braid_Access_F90(/;"	s
braid_App	xbraid/braid/braid.h	/^typedef struct _braid_App_struct *braid_App;$/;"	t	typeref:struct:_braid_App_struct
braid_BaseVector	xbraid/braid/_braid.h	/^typedef struct _braid_BaseVector_struct *braid_BaseVector;$/;"	t	typeref:struct:_braid_BaseVector_struct
braid_BufPack_F90	xbraid/examples/ex-01-expanded-f.f90	/^subroutine braid_BufPack_F90(/;"	s
braid_BufSize_F90	xbraid/examples/ex-01-expanded-f.f90	/^subroutine braid_BufSize_F90(/;"	s
braid_BufUnPack_F90	xbraid/examples/ex-01-expanded-f.f90	/^subroutine braid_BufUnPack_F90(/;"	s
braid_BufferStatus	xbraid/braid/braid_status.h	/^typedef struct _braid_BufferStatus_struct *braid_BufferStatus;$/;"	t	typeref:struct:_braid_BufferStatus_struct
braid_Clone_F90	xbraid/examples/ex-01-expanded-f.f90	/^subroutine braid_Clone_F90(/;"	s
braid_CoarsenRefStatus	xbraid/braid/braid_status.h	/^typedef struct _braid_CoarsenRefStatus_struct *braid_CoarsenRefStatus;$/;"	t	typeref:struct:_braid_CoarsenRefStatus_struct
braid_Core	xbraid/braid/braid.h	/^typedef struct _braid_Core_struct *braid_Core;$/;"	t	typeref:struct:_braid_Core_struct
braid_ERROR_ARG	xbraid/braid/braid.h	86;"	d
braid_ERROR_GENERIC	xbraid/braid/braid.h	84;"	d
braid_ERROR_MEMORY	xbraid/braid/braid.h	85;"	d
braid_FMANGLE	xbraid/braid/braid.h	62;"	d
braid_Fortran_Residual	xbraid/braid/braid.h	66;"	d
braid_Fortran_SpatialCoarsen	xbraid/braid/braid.h	64;"	d
braid_Fortran_TimeGrid	xbraid/braid/braid.h	68;"	d
braid_Free_F90	xbraid/examples/ex-01-expanded-f.f90	/^subroutine braid_Free_F90(/;"	s
braid_HEADER	xbraid/braid/braid.h	32;"	d
braid_INVALID_RNORM	xbraid/braid/braid.h	82;"	d
braid_Init_Vec_F90	xbraid/examples/ex-01-expanded-f.f90	/^subroutine braid_Init_Vec_F90(/;"	s
braid_Int	xbraid/braid/braid_defs.h	/^typedef int    braid_Int;$/;"	t
braid_Int_Max	xbraid/braid/braid_defs.h	50;"	d
braid_Int_Min	xbraid/braid/braid_defs.h	51;"	d
braid_MPI_INT	xbraid/braid/braid_defs.h	67;"	d
braid_MPI_REAL	xbraid/braid/braid_defs.h	66;"	d
braid_ObjectiveStatus	xbraid/braid/braid_status.h	/^typedef struct _braid_ObjectiveStatus_struct *braid_ObjectiveStatus;$/;"	t	typeref:struct:_braid_ObjectiveStatus_struct
braid_Optim	xbraid/braid/_braid.h	/^typedef struct _braid_Optimization_struct *braid_Optim;$/;"	t	typeref:struct:_braid_Optimization_struct
braid_PtFcnAccess	xbraid/braid/braid.h	/^(*braid_PtFcnAccess)(braid_App           app,              \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnBufPack	xbraid/braid/braid.h	/^(*braid_PtFcnBufPack)(braid_App           app,            \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnBufSize	xbraid/braid/braid.h	/^(*braid_PtFcnBufSize)(braid_App   app,               \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnBufUnpack	xbraid/braid/braid.h	/^(*braid_PtFcnBufUnpack)(braid_App            app,           \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnClone	xbraid/braid/braid.h	/^(*braid_PtFcnClone)(braid_App      app,          \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnFree	xbraid/braid/braid.h	/^(*braid_PtFcnFree)(braid_App     app,            \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnInit	xbraid/braid/braid.h	/^(*braid_PtFcnInit)(braid_App      app,           \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnObjectiveT	xbraid/braid/braid.h	/^(*braid_PtFcnObjectiveT)(braid_App             app,              \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnObjectiveTDiff	xbraid/braid/braid.h	/^(*braid_PtFcnObjectiveTDiff)(braid_App             app,       \/**< input \/ output: user-defined _braid_App structure, used to store gradient *\/$/;"	t
braid_PtFcnPostprocessObjective	xbraid/braid/braid.h	/^(*braid_PtFcnPostprocessObjective)(braid_App    app,             \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnPostprocessObjective_diff	xbraid/braid/braid.h	/^(*braid_PtFcnPostprocessObjective_diff)(braid_App    app,        \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnResetGradient	xbraid/braid/braid.h	/^(*braid_PtFcnResetGradient)(braid_App app          \/**< output: user-defined _braid_App structure, used to store gradient *\/$/;"	t
braid_PtFcnResidual	xbraid/braid/braid.h	/^(*braid_PtFcnResidual)(braid_App        app,    \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnSClone	xbraid/braid/braid.h	/^(*braid_PtFcnSClone)(braid_App      app,         \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnSCoarsen	xbraid/braid/braid.h	/^(*braid_PtFcnSCoarsen)(braid_App               app,    \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnSFree	xbraid/braid/braid.h	/^(*braid_PtFcnSFree)(braid_App     app,            \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnSInit	xbraid/braid/braid.h	/^(*braid_PtFcnSInit)(braid_App     app,           \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnSRefine	xbraid/braid/braid.h	/^(*braid_PtFcnSRefine)(braid_App               app,    \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnSpatialNorm	xbraid/braid/braid.h	/^(*braid_PtFcnSpatialNorm)(braid_App      app,      \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnStep	xbraid/braid/braid.h	/^(*braid_PtFcnStep)(braid_App        app,    \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnStepDiff	xbraid/braid/braid.h	/^(*braid_PtFcnStepDiff)(braid_App        app,       \/**< input \/ output: user-defined _braid_App structure, used to store gradient *\/$/;"	t
braid_PtFcnSum	xbraid/braid/braid.h	/^(*braid_PtFcnSum)(braid_App     app,             \/**< user-defined _braid_App structure *\/$/;"	t
braid_PtFcnTimeGrid	xbraid/braid/braid.h	/^(*braid_PtFcnTimeGrid)(braid_App         app,       \/**< user-defined _braid_App structure *\/$/;"	t
braid_RAND_MAX	xbraid/braid/braid_defs.h	129;"	d
braid_Real	xbraid/braid/braid_defs.h	/^typedef double braid_Real;$/;"	t
braid_Residual_F90	xbraid/examples/ex-01-expanded-f.f90	/^subroutine braid_Residual_F90(/;"	s
braid_SpatialNorm_F90	xbraid/examples/ex-01-expanded-f.f90	/^subroutine braid_SpatialNorm_F90(/;"	s
braid_Status	xbraid/braid/braid_status.h	/^typedef struct _braid_Status_struct *braid_Status;$/;"	t	typeref:struct:_braid_Status_struct
braid_StepStatus	xbraid/braid/braid_status.h	/^typedef struct _braid_StepStatus_struct *braid_StepStatus;$/;"	t	typeref:struct:_braid_StepStatus_struct
braid_Step_F90	xbraid/examples/ex-01-expanded-f.f90	/^subroutine braid_Step_F90(/;"	s
braid_Sum_F90	xbraid/examples/ex-01-expanded-f.f90	/^subroutine braid_Sum_F90(/;"	s
braid_Vector	xbraid/braid/braid.h	/^typedef struct _braid_Vector_struct *braid_Vector;$/;"	t	typeref:struct:_braid_Vector_struct
braid_VectorBar	xbraid/braid/_braid.h	/^typedef struct _braid_VectorBar_struct *braid_VectorBar;$/;"	t	typeref:struct:_braid_VectorBar_struct
braid_abstol	include/config.hpp	/^      MyReal braid_abstol;$/;"	m	class:Config
braid_abstoladj	include/config.hpp	/^      MyReal braid_abstoladj;$/;"	m	class:Config
braid_accesslevel	include/config.hpp	/^      int    braid_accesslevel;$/;"	m	class:Config
braid_cfactor	include/config.hpp	/^      int    braid_cfactor;$/;"	m	class:Config
braid_cfactor0	include/config.hpp	/^      int    braid_cfactor0; $/;"	m	class:Config
braid_core	xbraid/examples/ex-01-expanded-f.f90	/^   integer (kind=8)  :: braid_core$/;"	v	module:braid_types
braid_fmg	include/config.hpp	/^      int    braid_fmg;$/;"	m	class:Config
braid_hpp_HEADER	xbraid/braid/braid.hpp	23;"	d
braid_hypre_extra_HEADER	xbraid/drivers/hypre_extra.hpp	23;"	d
braid_isnan	xbraid/braid/braid_defs.h	122;"	d
braid_iter	xbraid/braid/_braid_tape.h	/^   braid_Int         braid_iter;       \/**< iteration number of xBraid *\/$/;"	m	struct:_braid_Action_struct
braid_iter	xbraid/drivers/braid_mfem_block.hpp	/^    int braid_iter;$/;"	m	class:MFEMBraidApp
braid_maxiter	include/config.hpp	/^      int    braid_maxiter;$/;"	m	class:Config
braid_maxlevels	include/config.hpp	/^      int    braid_maxlevels;$/;"	m	class:Config
braid_maxlevelslist	testing/testing.py	/^braid_maxlevelslist = args.maxlevels$/;"	v
braid_mfem_HEADER	xbraid/drivers/braid_mfem.hpp	23;"	d
braid_mfem_HEADER	xbraid/drivers/braid_mfem_block.hpp	23;"	d
braid_mincoarse	include/config.hpp	/^      int    braid_mincoarse;$/;"	m	class:Config
braid_nrelax	include/config.hpp	/^      int    braid_nrelax;$/;"	m	class:Config
braid_nrelax0	include/config.hpp	/^      int    braid_nrelax0;$/;"	m	class:Config
braid_printlevel	include/config.hpp	/^      int    braid_printlevel;$/;"	m	class:Config
braid_setskip	include/config.hpp	/^      int    braid_setskip;$/;"	m	class:Config
braid_status_HEADER	xbraid/braid/braid_status.h	32;"	d
braid_tape_HEADER	xbraid/braid/_braid_tape.h	8;"	d
braid_test_HEADER	xbraid/braid/braid_test.h	33;"	d
braid_timegrid_f90	xbraid/examples/ex-01-expanded-f.f90	/^subroutine braid_timegrid_f90(/;"	s
braid_types	xbraid/examples/ex-01-expanded-f.f90	/^module braid_types$/;"	m
braid_util_HEADER	xbraid/braid/_util.h	34;"	d
braiddefs_HEADER	xbraid/braid/braid_defs.h	31;"	d
bstatus	xbraid/braid/braid.hpp	/^      braid_BufferStatus bstatus;$/;"	m	class:BraidBufferStatus
buff_size	xbraid/drivers/braid_mfem.hpp	/^   Array<int>                buff_size;$/;"	m	class:MFEMBraidApp
buff_size	xbraid/drivers/braid_mfem_block.hpp	/^    Array<int>           buff_size;$/;"	m	class:MFEMBraidApp
buffer	xbraid/braid/_braid.h	/^   void             *buffer;          \/**< Buffer for message *\/$/;"	m	struct:__anon2
bufpack	xbraid/braid/_braid.h	/^   braid_PtFcnBufPack     bufpack;          \/**< pack a buffer *\/$/;"	m	struct:_braid_Core_struct
bufsize	xbraid/braid/_braid.h	/^   braid_PtFcnBufSize     bufsize;          \/**< return buffer size *\/$/;"	m	struct:_braid_Core_struct
bufunpack	xbraid/braid/_braid.h	/^   braid_PtFcnBufUnpack   bufunpack;        \/**< unpack a buffer *\/$/;"	m	struct:_braid_Core_struct
c_tprior	xbraid/braid/_braid.h	/^   braid_Real    c_tprior;         \/**< time value to the left of tstart on coarse grid *\/$/;"	m	struct:_braid_Core_struct
c_tstop	xbraid/braid/_braid.h	/^   braid_Real    c_tstop;          \/**< time value to the right of tstart on coarse grid *\/$/;"	m	struct:_braid_Core_struct
calling_function	xbraid/braid/_braid.h	/^   braid_Int     calling_function; \/**< from which function are we accessing the vector *\/$/;"	m	struct:_braid_Core_struct
case	testing/testing.py	/^case = args.case$/;"	v
cfactor	xbraid/braid/_braid.h	/^   braid_Int          cfactor;       \/**< coarsening factor *\/$/;"	m	struct:__anon3
cfactor	xbraid/drivers/braid_mfem.hpp	/^   int    cfactor;$/;"	m	struct:BraidOptions
cfactor	xbraid/drivers/braid_mfem_block.hpp	/^    int  cfactor;$/;"	m	struct:BraidOptions
cfactor	xbraid/examples/ex-01-expanded-f.f90	/^   integer ierr, rc, max_levels, nrelax, nrelax0, cfactor,/;"	v	program:ex01_f90
cfactor0	xbraid/drivers/braid_mfem.hpp	/^   int    cfactor0;$/;"	m	struct:BraidOptions
cfactor0	xbraid/drivers/braid_mfem_block.hpp	/^    int  cfactor0;$/;"	m	struct:BraidOptions
cfactor0	xbraid/examples/ex-01-expanded-f.f90	/^   integer ierr, rc, max_levels, nrelax, nrelax0, cfactor, cfactor0$/;"	v	program:ex01_f90
cfactors	xbraid/braid/_braid.h	/^   braid_Int             *cfactors;         \/**< coarsening factors *\/$/;"	m	struct:_braid_Core_struct
cfdefault	xbraid/braid/_braid.h	/^   braid_Int              cfdefault;        \/**< default coarsening factor *\/$/;"	m	struct:_braid_Core_struct
clear	pythonutil/ordered_dict.py	/^    def clear(self):$/;"	m	class:OrderedDict
clone	xbraid/braid/_braid.h	/^   braid_PtFcnClone       clone;            \/**< clone a vector *\/$/;"	m	struct:_braid_Core_struct
clone	xbraid/drivers/braid_mfem.hpp	/^   BraidVector *clone()$/;"	f	class:BraidVector
clone	xbraid/drivers/braid_mfem_block.hpp	/^    BraidVector *clone()$/;"	f	class:BraidVector
clower	xbraid/braid/_braid.h	/^   braid_Int          clower;        \/**< smallest C point index *\/$/;"	m	struct:__anon3
comm	include/network.hpp	/^      MPI_Comm comm;                \/* MPI communicator *\/$/;"	m	class:Network
comm	xbraid/braid/_braid.h	/^   MPI_Comm               comm;             \/**< communicator for the time dimension *\/$/;"	m	struct:_braid_Core_struct
comm	xbraid/drivers/mfem_arnoldi.hpp	/^        MPI_Comm comm;$/;"	m	class:Arnoldi
comm	xbraid/examples/ex-01-expanded-f.f90	/^      integer                       :: comm$/;"	k	type:my_app
comm_t	xbraid/braid/braid.hpp	/^   MPI_Comm     comm_t;$/;"	m	class:BraidApp
comm_world	xbraid/braid/_braid.h	/^   MPI_Comm               comm_world;$/;"	m	struct:_braid_Core_struct
comparefiles	pythonutil/util.py	/^def comparefiles(refname, testname):$/;"	f
config	testing/testing.py	/^config = Config(case + ".cfg")$/;"	v
config_option	include/config.hpp	/^      struct config_option {$/;"	s	class:Config
configfile	examples/mnist/mnist_runs/submit_paramstudy.py	/^configfile = Config("config.cfg")$/;"	v
configfile	pythonutil/submit_paramstudy.py	/^configfile = Config("config.cfg")$/;"	v
copy	pythonutil/ordered_dict.py	/^    def copy(self):$/;"	m	class:OrderedDict
core	include/braid_wrapper.hpp	/^        BraidCore* core;       \/* Braid core for running PinT simulation *\/$/;"	m	class:myBraidApp
core	xbraid/braid/_braid_status.h	/^   _braid_Core core;$/;"	m	struct:_braid_Status_struct
core	xbraid/braid/_braid_tape.h	/^   braid_Core        core;             \/**< pointer to braid's core structure *\/$/;"	m	struct:_braid_Action_struct
core	xbraid/braid/braid.hpp	/^   braid_Core core;$/;"	m	class:BraidCore
csize	include/layer.hpp	/^      int csize;$/;"	m	class:Layer
csize2	include/layer.hpp	/^     int csize2;$/;"	m	class:ConvLayer
cstatus	xbraid/braid/braid.hpp	/^      braid_CoarsenRefStatus cstatus;$/;"	m	class:BraidCoarsenRefStatus
cupper	xbraid/braid/_braid.h	/^   braid_Int          cupper;        \/**< largest C point index *\/$/;"	m	struct:__anon3
current_lvl	xbraid/misc/user_utils/cycleplot.py	/^         current_lvl = 0$/;"	v
current_lvl	xbraid/misc/user_utils/cycleplot.py	/^         current_lvl = data[-1,0]$/;"	v
current_rank	xbraid/examples/viz-ex-02.py	/^        current_rank = current_rank + 1$/;"	v
current_rank	xbraid/examples/viz-ex-02.py	/^current_rank = 0$/;"	v
current_rank	xbraid/examples/viz-ex-04.py	/^            current_rank = current_rank + 1$/;"	v
current_rank	xbraid/examples/viz-ex-04.py	/^    current_rank = 0$/;"	v
cycleplot	xbraid/misc/user_utils/cycleplot.m	/^function cycleplot(filename);$/;"	f
data	include/braid_wrapper.hpp	/^        DataSet*   data;       \/* Pointer to the Data set *\/$/;"	m	class:myBraidApp
data	xbraid/drivers/viz-burgers-1D.py	/^data = loadtxt(fname)$/;"	v
data	xbraid/drivers/viz-burgers-1D.py	/^data = zeros((nsteps,data.shape[0]-6))$/;"	v
data	xbraid/drivers/viz-lorenz.py	/^data = numpy.loadtxt('drive-lorenz.out')$/;"	v
data	xbraid/examples/viz-ex-02.py	/^data = loadtxt(fname)$/;"	v
data	xbraid/examples/viz-ex-02.py	/^data = zeros((nsteps,data.shape[0]-6))$/;"	v
data	xbraid/misc/user_utils/cycleplot.py	/^         data = loadtxt(fname)$/;"	v
data_ptr	xbraid/braid/_braid_tape.h	/^    void *data_ptr;$/;"	m	struct:_braid_tape_struct
datafolder	examples/mnist/mnist_runs/submit_paramstudy.py	/^datafolder = "data"$/;"	v
datafolder	include/config.hpp	/^      const char* datafolder;        $/;"	m	class:Config
datafolder	pythonutil/submit_paramstudy.py	/^datafolder = "data"$/;"	v
datafolder	testing/testing.py	/^        datafolder = "..\/" + config.datafolder$/;"	v
default_batch_args	pythonutil/batch_job.py	/^default_batch_args = {batch_args_mapping["NAME"]          : "default",$/;"	v
design	include/network.hpp	/^      MyReal* design;               \/* Local vector of design variables*\/$/;"	m	class:Network
design	xbraid/examples/viz-ex-04.py	/^design = loadtxt('ex-04.out.design')$/;"	v
design_old	include/hessianApprox.hpp	/^      MyReal*  design_old;    \/* Design at previous iteration *\/$/;"	m	class:L_BFGS
design_old	include/hessianApprox.hpp	/^      MyReal* design_old;    \/* Design at previous iteration *\/$/;"	m	class:BFGS
dimN	include/hessianApprox.hpp	/^      int      dimN;          \/* Dimension of the gradient vector *\/$/;"	m	class:HessianApprox
dim_Bias	include/layer.hpp	/^      int dim_Bias;                        \/* Dimension of the bias vector *\/$/;"	m	class:Layer
dim_In	include/layer.hpp	/^      int dim_In;                          \/* Dimension of incoming data *\/$/;"	m	class:Layer
dim_Out	include/layer.hpp	/^      int dim_Out;                         \/* Dimension of outgoing data *\/$/;"	m	class:Layer
done	xbraid/braid/_braid.h	/^   braid_Int     done;             \/**< boolean describing whether XBraid has finished *\/$/;"	m	struct:_braid_Core_struct
dr	xbraid/misc/user_utils/cycleplot.py	/^         dr = r[:-1] - r[1:]$/;"	v
dt	include/layer.hpp	/^      MyReal  dt;                          \/* Step size for Layer update *\/$/;"	m	class:Layer
dt	include/network.hpp	/^      MyReal  dt;                   \/* Time step size *\/$/;"	m	class:Network
dt	xbraid/examples/ex-01-expanded-f.f90	/^      double precision, allocatable :: dt(/;"	k	type:my_app
dump	pythonutil/config.py	/^    def dump(self,filename=''):$/;"	m	class:Config
dump_config	pythonutil/config.py	/^def dump_config(filename,config):$/;"	f
endlayerID	include/network.hpp	/^      int     endlayerID;           \/* ID of the last layer on that processor *\/$/;"	m	class:Network
err	testing/testing.py	/^        err = comparefiles(refname, testfoldername + "\/" + outfile)$/;"	v
ex01_f90	xbraid/examples/ex-01-expanded-f.f90	/^program ex01_f90$/;"	p
exact_sol	xbraid/drivers/braid_mfem.hpp	/^   Coefficient *exact_sol;$/;"	m	class:MFEMBraidApp
exact_sol	xbraid/drivers/braid_mfem_block.hpp	/^    Coefficient *exact_sol;$/;"	m	class:MFEMBraidApp
example	include/layer.hpp	/^            MyReal* example;    \/* Pointer to the current example data *\/$/;"	m	class:OpenExpandZero
example	include/layer.hpp	/^      MyReal* example;    \/* Pointer to the current example data *\/$/;"	m	class:OpenConvLayer
example	include/layer.hpp	/^      MyReal* example;    \/* Pointer to the current example data *\/$/;"	m	class:OpenDenseLayer
examples	include/dataset.hpp	/^      MyReal **examples;    \/* Array of Feature vectors (dim: nelements x nfeatures) *\/$/;"	m	class:DataSet
f_bar	xbraid/braid/_braid.h	/^   braid_Real       f_bar;            \/**< contains the seed for tape evaluation  *\/$/;"	m	struct:_braid_Optimization_struct
f_tprior	xbraid/braid/_braid.h	/^   braid_Real    f_tprior;         \/**< time value to the left of tstart on fine grid *\/$/;"	m	struct:_braid_Core_struct
f_tstop	xbraid/braid/_braid.h	/^   braid_Real    f_tstop;          \/**< time value to the right of tstart  on fine grid *\/$/;"	m	struct:_braid_Core_struct
fa	xbraid/braid/_braid.h	/^   braid_BaseVector  *fa;            \/**< rhs vectors f              (all points, NULL on level 0) *\/$/;"	m	struct:__anon3
fa_alloc	xbraid/braid/_braid.h	/^   braid_BaseVector  *fa_alloc;      \/**< original memory allocation for fa *\/$/;"	m	struct:__anon3
fcsize	include/layer.hpp	/^     int fcsize;$/;"	m	class:ConvLayer
fe_space	xbraid/drivers/braid_mfem.hpp	/^   Array<ParFiniteElementSpace *> fe_space;$/;"	m	class:MFEMBraidApp
fe_space	xbraid/drivers/braid_mfem_block.hpp	/^    Array<ParFiniteElementSpace *> fe_space;$/;"	m	class:MFEMBraidApp
fig_size	xbraid/misc/user_utils/cycleplot.py	/^      fig_size = [niter*1.7, nlevels*1.0]$/;"	v
file_stem	xbraid/drivers/viz-burgers-1D.py	/^file_stem = 'drive-burgers-1D.out.'$/;"	v
file_stem	xbraid/examples/viz-ex-02.py	/^file_stem = 'ex-02.out.'$/;"	v
file_stem	xbraid/examples/viz-ex-04.py	/^    file_stem = "ex-04.out."$/;"	v
fmg	xbraid/braid/_braid.h	/^   braid_Int              fmg;              \/**< use FMG cycle *\/$/;"	m	struct:_braid_Core_struct
fmg	xbraid/examples/ex-01-expanded-f.f90	/^   integer max_iter, fmg,/;"	v	program:ex01_f90
fname	xbraid/drivers/viz-burgers-1D.py	/^    fname = file_stem + "%07d"%step + '.' + "%05d"%rank$/;"	v
fname	xbraid/drivers/viz-burgers-1D.py	/^fname = file_stem + "%07d"%step + '.' + "%05d"%rank$/;"	v
fname	xbraid/examples/viz-ex-02.py	/^        fname = file_stem + "%07d"%step + '.' + "%05d"%current_rank$/;"	v
fname	xbraid/examples/viz-ex-02.py	/^fname = file_stem + "%07d"%step + '.' + "%05d"%current_rank$/;"	v
fname	xbraid/examples/viz-ex-04.py	/^            fname = file_stem + "%04d"%step + '.' + "%03d"%current_rank$/;"	v
fname	xbraid/misc/user_utils/cycleplot.py	/^         fname = "braid.out.cycle"$/;"	v
fontsize	xbraid/misc/user_utils/cycleplot.py	/^      fontsize = 22$/;"	v
free	xbraid/braid/_braid.h	/^   braid_PtFcnFree        free;             \/**< free up a vector *\/$/;"	m	struct:_braid_Core_struct
fromOrderedDict	pythonutil/ordered_bunch.py	/^    def fromOrderedDict(d):$/;"	m	class:OrderedBunch
fromYAML	pythonutil/ordered_bunch.py	/^    def fromYAML(*args, **kwargs):$/;"	f
from_yaml	pythonutil/ordered_bunch.py	/^    def from_yaml(loader, node):$/;"	f
fromkeys	pythonutil/ordered_dict.py	/^    def fromkeys(cls, iterable, value=None):$/;"	m	class:OrderedDict
ftrain_ex	include/config.hpp	/^      const char* ftrain_ex;$/;"	m	class:Config
ftrain_labels	include/config.hpp	/^      const char* ftrain_labels;$/;"	m	class:Config
full_rnorm0	xbraid/braid/_braid.h	/^   braid_Real             full_rnorm0;      \/**< (optional) initial full residual norm *\/$/;"	m	struct:_braid_Core_struct
full_rnorm_res	xbraid/braid/_braid.h	/^   braid_PtFcnResidual    full_rnorm_res;   \/**< (optional) used to compute full residual norm *\/$/;"	m	struct:_braid_Core_struct
full_rnorms	xbraid/braid/_braid.h	/^   braid_Real            *full_rnorms;      \/**< (optional) full residual norm history *\/$/;"	m	struct:_braid_Core_struct
fval_ex	include/config.hpp	/^      const char* fval_ex;$/;"	m	class:Config
fval_labels	include/config.hpp	/^      const char* fval_labels;$/;"	m	class:Config
gamma_class	include/config.hpp	/^      MyReal gamma_class;$/;"	m	class:Config
gamma_ddt	include/config.hpp	/^      MyReal gamma_ddt;$/;"	m	class:Config
gamma_ddt	include/layer.hpp	/^      MyReal  gamma_ddt;                   \/* Parameter for DDT regularization of weights and bias *\/$/;"	m	class:Layer
gamma_tik	include/config.hpp	/^      MyReal gamma_tik;$/;"	m	class:Config
gamma_tik	include/layer.hpp	/^      MyReal  gamma_tik;                   \/* Parameter for Tikhonov regularization of weights and bias *\/$/;"	m	class:Layer
gammaclass	examples/mnist/mnist_runs/submit_paramstudy.py	/^gammaclass = [1e-1,1e-3,1e-5]$/;"	v
gammaclass	pythonutil/submit_paramstudy.py	/^gammaclass = [1e-1, 1e-5]$/;"	v
gammaddt	examples/mnist/mnist_runs/submit_paramstudy.py	/^gammaddt   = [1e-1,1e-3,1e-5]$/;"	v
gammaddt	pythonutil/submit_paramstudy.py	/^gammaddt   = [1e-5]$/;"	v
gammatik	examples/mnist/mnist_runs/submit_paramstudy.py	/^gammatik   = [1e-1,1e-3,1e-5]$/;"	v
gammatik	pythonutil/submit_paramstudy.py	/^gammatik   = [1e-5]$/;"	v
globaltime	xbraid/braid/_braid.h	/^   braid_Real             globaltime;       \/**< global wall time for braid_Drive() *\/$/;"	m	struct:_braid_Core_struct
gradient	include/network.hpp	/^      MyReal* gradient;             \/* Local Gradient *\/$/;"	m	class:Network
gradient_old	include/hessianApprox.hpp	/^      MyReal*  gradient_old;  \/* Gradient at previous iteration *\/$/;"	m	class:L_BFGS
gradient_old	include/hessianApprox.hpp	/^      MyReal* gradient_old;  \/* Gradient at previous iteration *\/$/;"	m	class:BFGS
grids	xbraid/braid/_braid.h	/^   _braid_Grid          **grids;            \/**< pointer to temporal grid structures for each level*\/$/;"	m	struct:_braid_Core_struct
gtol	include/config.hpp	/^      MyReal gtol;$/;"	m	class:Config
guess	xbraid/drivers/braid_mfem_block.hpp	/^  BlockVector *guess; $/;"	m	class:MFEMBraidApp
gupper	xbraid/braid/_braid.h	/^   braid_Int              gupper;           \/**< global size of the fine grid *\/$/;"	m	struct:_braid_Core_struct
gupper	xbraid/braid/_braid.h	/^   braid_Int          gupper;        \/**< global size of the grid *\/$/;"	m	struct:__anon3
gupper	xbraid/braid/_braid_tape.h	/^   braid_Int         gupper;           \/**< global size of the fine grid *\/$/;"	m	struct:_braid_Action_struct
hessianapprox_type	include/config.hpp	/^      int    hessianapprox_type;$/;"	m	class:Config
hessiantype	include/config.hpp	/^enum hessiantype{BFGS_SERIAL, LBFGS, IDENTITY};$/;"	g
hypre	xbraid/drivers/hypre_extra.hpp	/^namespace hypre$/;"	n
hypre_CSRMatrixSetConstantValues	xbraid/drivers/hypre_extra.hpp	/^   hypre_CSRMatrixSetConstantValues( hypre_CSRMatrix *A,$/;"	f	namespace:hypre
hypre_CSRMatrixSum	xbraid/drivers/hypre_extra.hpp	/^   hypre_CSRMatrixSum( hypre_CSRMatrix *A,$/;"	f	namespace:hypre
hypre_ParCSRMatrixAdd	xbraid/drivers/hypre_extra.hpp	/^   hypre_ParCSRMatrixAdd( hypre_ParCSRMatrix *A,$/;"	f	namespace:hypre
hypre_ParCSRMatrixSetConstantValues	xbraid/drivers/hypre_extra.hpp	/^   hypre_ParCSRMatrixSetConstantValues( hypre_ParCSRMatrix *A,$/;"	f	namespace:hypre
hypre_ParCSRMatrixSum	xbraid/drivers/hypre_extra.hpp	/^   hypre_ParCSRMatrixSum( hypre_ParCSRMatrix *A,$/;"	f	namespace:hypre
i	xbraid/examples/ex-01-expanded-f.f90	/^   in/;"	v	program:ex01_f90
idx	xbraid/braid/_braid.h	/^   braid_Int     idx;              \/**< time point index value corresponding to t on the global time grid *\/$/;"	m	struct:_braid_Core_struct
ierr	xbraid/examples/ex-01-expanded-f.f90	/^   integer ierr,/;"	v	program:ex01_f90
ilower	xbraid/braid/_braid.h	/^   braid_Int          ilower;        \/**< smallest time index at this level*\/$/;"	m	struct:__anon3
img_size	include/layer.hpp	/^     int img_size;$/;"	m	class:ConvLayer
img_size_sqrt	include/layer.hpp	/^     int img_size_sqrt;$/;"	m	class:ConvLayer
inTime	xbraid/braid/_braid_tape.h	/^   braid_Real        inTime;           \/**< time of the input vector *\/$/;"	m	struct:_braid_Action_struct
inTimeIdx	xbraid/braid/_braid_tape.h	/^   braid_Int         inTimeIdx;        \/**< index of time of input vector *\/$/;"	m	struct:_braid_Action_struct
index	include/layer.hpp	/^      int     index;                       \/* Number of the layer *\/$/;"	m	class:Layer
inf	pythonutil/config.py	/^inf = 1.0e20$/;"	v
init	xbraid/braid/_braid.h	/^   braid_PtFcnInit        init;             \/**< return an initialized braid_BaseVector *\/$/;"	m	struct:_braid_Core_struct
init_rand	xbraid/drivers/braid_mfem.hpp	/^   bool init_rand;     \/* If true, use std::rand() to initialize BraidVectors in$/;"	m	class:MFEMBraidApp
init_timesteps	xbraid/examples/ex-01-expanded-f.f90	/^subroutine init_timesteps(/;"	s
interactive	xbraid/misc/user_utils/cycleplot.py	/^      interactive = 0$/;"	v
interactive	xbraid/misc/user_utils/cycleplot.py	/^      interactive = float(argv[1])$/;"	v
io_level	xbraid/braid/_braid.h	/^   braid_Int              io_level;         \/**< determines amount of output printed to files (0,1) *\/$/;"	m	struct:_braid_Core_struct
items	pythonutil/ordered_dict.py	/^    def items(self):$/;"	m	class:OrderedDict
iteritems	pythonutil/ordered_dict.py	/^    def iteritems(self):$/;"	m	class:OrderedDict
iterkeys	pythonutil/ordered_dict.py	/^    def iterkeys(self):$/;"	m	class:OrderedDict
itervalues	pythonutil/ordered_dict.py	/^    def itervalues(self):$/;"	m	class:OrderedDict
iupper	xbraid/braid/_braid.h	/^   braid_Int          iupper;        \/**< largest time index at this level*\/$/;"	m	struct:__anon3
jobname	examples/mnist/mnist_runs/submit_paramstudy.py	/^                      "-class"   + str(konfig.gamma_class)$/;"	v
jobname	pythonutil/submit_paramstudy.py	/^                      "class"   + str(konfig.gamma_class)$/;"	v
k_max	xbraid/drivers/mfem_arnoldi.hpp	/^        int k_max;$/;"	m	class:Arnoldi
key	include/config.hpp	/^         char key[CONFIG_ARG_MAX_BYTES];$/;"	m	struct:Config::config_option
keys	pythonutil/ordered_dict.py	/^    def keys(self):$/;"	m	class:OrderedDict
konfig	examples/mnist/mnist_runs/submit_paramstudy.py	/^            konfig = copy.deepcopy(configfile)$/;"	v
konfig	pythonutil/submit_paramstudy.py	/^            konfig = copy.deepcopy(configfile)$/;"	v
konfig	testing/testing.py	/^        konfig = copy.deepcopy(config)$/;"	v
label	include/layer.hpp	/^            MyReal* label;                \/* Pointer to the current label vector *\/$/;"	m	class:ClassificationLayer
labels	include/dataset.hpp	/^      MyReal **labels;      \/* Array of Label vectors (dim: nelements x nlabels) *\/$/;"	m	class:DataSet
layer	include/braid_wrapper.hpp	/^        Layer* layer;     \/* Pointer to layer information *\/$/;"	m	class:myBraidVector
layer_left	include/network.hpp	/^      Layer*  layer_left;           \/* Copy of last layer of left-neighbouring processor *\/$/;"	m	class:Network
layer_right	include/network.hpp	/^      Layer*  layer_right;          \/* Copy of first layer of right-neighbouring processor *\/$/;"	m	class:Network
layers	include/network.hpp	/^      Layer** layers;               \/* Array of hidden layers (includes classification layer at last processor *\/$/;"	m	class:Network
layertype	include/layer.hpp	/^      enum layertype{OPENZERO=0, OPENDENSE=1, DENSE=2, CLASSIFICATION=3, OPENCONV=4, OPENCONVMNIST=5, CONVOLUTION=6};$/;"	g	class:Layer
lbfgs_stages	include/config.hpp	/^      int    lbfgs_stages;$/;"	m	class:Config
level	xbraid/braid/_braid.h	/^   braid_Int          level;         \/**< Level that grid is on *\/$/;"	m	struct:__anon3
level	xbraid/braid/_braid.h	/^   braid_Int     level;            \/**< current level in XBraid*\/$/;"	m	struct:_braid_Core_struct
level	xbraid/braid/_braid_tape.h	/^   braid_Int         level;            \/**< current level in Braid *\/$/;"	m	struct:_braid_Action_struct
level	xbraid/drivers/braid_mfem.hpp	/^   int level;$/;"	m	class:BraidVector
level	xbraid/misc/user_utils/cycleplot.py	/^      level = -level$/;"	v
level	xbraid/misc/user_utils/cycleplot.py	/^      level = data[:,0] - data[:,1]$/;"	v
localtime	xbraid/braid/_braid.h	/^   braid_Real             localtime;        \/**< local wall time for braid_Drive() *\/$/;"	m	struct:_braid_Core_struct
loss	include/network.hpp	/^      MyReal  loss;                 \/* Value of the loss function *\/$/;"	m	class:Network
ls_factor	include/config.hpp	/^      MyReal ls_factor;$/;"	m	class:Config
ls_maxiter	include/config.hpp	/^      int    ls_maxiter;$/;"	m	class:Config
ma	xbraid/misc/user_utils/cycleplot.py	/^         ma = r_to_print.max()$/;"	v
make_link	pythonutil/util.py	/^def make_link(src,dst):$/;"	f
match	pythonutil/switch.py	/^    def match(self, *args):$/;"	m	class:switch
maxBlocks	xbraid/drivers/braid_mfem_block.hpp	/^    static const int maxBlocks = 2;$/;"	m	class:MFEMBraidApp
max_dt	xbraid/drivers/braid_mfem.hpp	/^   Array<double>             max_dt; \/\/ maximal safe dt on each spatial mesh$/;"	m	class:MFEMBraidApp
max_dt	xbraid/drivers/braid_mfem_block.hpp	/^    Array<double>             max_dt; \/\/ maximal safe dt on each spatial mesh$/;"	m	class:MFEMBraidApp
max_iter	xbraid/braid/_braid.h	/^   braid_Int              max_iter;         \/**< maximum number of multigrid in time iterations *\/$/;"	m	struct:_braid_Core_struct
max_iter	xbraid/drivers/braid_mfem.hpp	/^   int    max_iter;$/;"	m	struct:BraidOptions
max_iter	xbraid/drivers/braid_mfem_block.hpp	/^    int  max_iter;$/;"	m	struct:BraidOptions
max_iter	xbraid/examples/ex-01-expanded-f.f90	/^   integer max_iter,/;"	v	program:ex01_f90
max_levels	xbraid/braid/_braid.h	/^   braid_Int              max_levels;       \/**< maximum number of temporal grid levels *\/$/;"	m	struct:_braid_Core_struct
max_levels	xbraid/drivers/braid_mfem.hpp	/^   int           max_levels;$/;"	m	class:SpaceTimeMeshInfo
max_levels	xbraid/drivers/braid_mfem.hpp	/^   int    max_levels;$/;"	m	struct:BraidOptions
max_levels	xbraid/drivers/braid_mfem_block.hpp	/^     int              max_levels;$/;"	m	class:SpaceTimeMeshInfo
max_levels	xbraid/drivers/braid_mfem_block.hpp	/^    int  max_levels;$/;"	m	struct:BraidOptions
max_levels	xbraid/examples/ex-01-expanded-f.f90	/^   integer ierr, rc, max_levels,/;"	v	program:ex01_f90
max_refinements	xbraid/braid/_braid.h	/^   braid_Int              max_refinements;  \/**< maximum number of refinements *\/$/;"	m	struct:_braid_Core_struct
maxl	xbraid/misc/user_utils/cycleplot.py	/^      maxl = max(level)$/;"	v
maxoptimiter	include/config.hpp	/^      int    maxoptimiter;$/;"	m	class:Config
mesh	xbraid/drivers/braid_mfem.hpp	/^   Array<ParMesh *>               mesh;$/;"	m	class:MFEMBraidApp
mesh	xbraid/drivers/braid_mfem_block.hpp	/^    Array<ParMesh *>                    mesh;$/;"	m	class:MFEMBraidApp
mesh	xbraid/drivers/viz-burgers-1D.py	/^mesh = linspace(xstart, xstop, nspace)$/;"	v
mesh	xbraid/examples/viz-ex-02.py	/^mesh = linspace(xstart, xstop, nspace)$/;"	v
mesh_file	xbraid/drivers/braid_mfem.hpp	/^   const char *mesh_file;$/;"	m	struct:BraidOptions
mesh_file	xbraid/drivers/braid_mfem_block.hpp	/^    const char *mesh_file;$/;"	m	struct:BraidOptions
mesh_table	xbraid/drivers/braid_mfem.hpp	/^   Array<double> mesh_table;$/;"	m	class:SpaceTimeMeshInfo
mesh_table	xbraid/drivers/braid_mfem_block.hpp	/^     Array<double> mesh_table;$/;"	m	class:SpaceTimeMeshInfo
mesh_table_global	xbraid/drivers/braid_mfem.hpp	/^   Array<double> mesh_table_global;$/;"	m	class:SpaceTimeMeshInfo
mesh_table_global	xbraid/drivers/braid_mfem_block.hpp	/^     Array<double> mesh_table_global;$/;"	m	class:SpaceTimeMeshInfo
messagetype	xbraid/braid/_braid.h	/^   braid_Int    messagetype;       \/**< message type, 0: for Step(), 1: for load balancing *\/$/;"	m	struct:_braid_Core_struct
messagetype	xbraid/braid/_braid_tape.h	/^   braid_Int         messagetype;      \/**< message type, 0: for Step(), 1: for load balancing *\/$/;"	m	struct:_braid_Action_struct
mfem	xbraid/drivers/braid_mfem_block.hpp	/^namespace mfem$/;"	n
mfem_arnoldi_HEADER	xbraid/drivers/mfem_arnoldi.hpp	2;"	d
mi	xbraid/misc/user_utils/cycleplot.py	/^         mi = min( tols[tols>0].min()\/500., r_to_print.min())$/;"	v
min_coarse	xbraid/braid/_braid.h	/^   braid_Int              min_coarse;       \/**< minimum possible coarse grid size *\/$/;"	m	struct:_braid_Core_struct
min_coarse	xbraid/drivers/braid_mfem.hpp	/^   int    min_coarse;$/;"	m	struct:BraidOptions
min_coarse	xbraid/drivers/braid_mfem_block.hpp	/^    int  min_coarse;$/;"	m	struct:BraidOptions
min_coarse	xbraid/examples/ex-01-expanded-f.f90	/^   integer min_coarse,/;"	v	program:ex01_f90
minl	xbraid/misc/user_utils/cycleplot.py	/^      minl = maxl - nlevels$/;"	v
myAdjointBraidApp	include/braid_wrapper.hpp	/^class myAdjointBraidApp : public myBraidApp$/;"	c
myBraidApp	include/braid_wrapper.hpp	/^class myBraidApp : public BraidApp$/;"	c
myBraidVector	include/braid_wrapper.hpp	/^class myBraidVector $/;"	c
my_app	xbraid/examples/ex-01-expanded-f.f90	/^   type my_app$/;"	t	module:braid_types
my_vector	xbraid/examples/ex-01-expanded-f.f90	/^   type my_vector$/;"	t	module:braid_types
mydt	xbraid/examples/ex-01-expanded-f.f90	/^      integer                       :: mydt$/;"	k	type:my_app
mydt	xbraid/examples/ex-01-expanded-f.f90	/^   integer mydt,/;"	v	program:ex01_f90
myid	include/braid_wrapper.hpp	/^        int        myid;       \/* Processor rank*\/$/;"	m	class:myBraidApp
myid	xbraid/braid/_braid.h	/^   braid_Int              myid;             \/**< my rank in the time communicator *\/$/;"	m	struct:_braid_Core_struct
myid	xbraid/braid/_braid_tape.h	/^   braid_Int         myid;             \/**< processors id *\/$/;"	m	struct:_braid_Action_struct
myid_world	xbraid/braid/_braid.h	/^   braid_Int              myid_world;       \/**< my rank in the world communicator *\/$/;"	m	struct:_braid_Core_struct
navail	include/dataset.hpp	/^      int  navail;            \/* Auxilliary: holding number of currently available batchIDs *\/$/;"	m	class:DataSet
nbatch	include/braid_wrapper.hpp	/^        int    nbatch;       \/* Number of examples *\/$/;"	m	class:myBraidVector
nbatch	include/config.hpp	/^      int    nbatch;$/;"	m	class:Config
nbatch	include/dataset.hpp	/^      int  nbatch;          \/* Size of the batch *\/$/;"	m	class:DataSet
nchannels	include/braid_wrapper.hpp	/^        int    nchannels;    \/* Number of channels *\/$/;"	m	class:myBraidVector
nchannels	include/config.hpp	/^      int    nchannels;$/;"	m	class:Config
nchannels	include/network.hpp	/^      int     nchannels;            \/* Width of the network *\/$/;"	m	class:Network
nclasses	include/config.hpp	/^      int nclasses;$/;"	m	class:Config
nconv	include/layer.hpp	/^      int nconv;$/;"	m	class:Layer
ncpoints	xbraid/braid/_braid.h	/^   braid_Int          ncpoints;      \/**< number of C points *\/$/;"	m	struct:__anon3
ndesign	include/layer.hpp	/^      int ndesign;                         \/* Total number of design variables *\/$/;"	m	class:Layer
ndesign_global	include/network.hpp	/^      int     ndesign_global;        \/* Global number of design vars  *\/$/;"	m	class:Network
ndesign_layermax	include/network.hpp	/^      int     ndesign_layermax;      \/* Max. number of design variables of all hidden layers *\/$/;"	m	class:Network
ndesign_local	include/network.hpp	/^      int     ndesign_local;         \/* Number of design vars of this local network block  *\/$/;"	m	class:Network
nelements	include/dataset.hpp	/^      int nelements;         \/* Number of data elements *\/$/;"	m	class:DataSet
network	include/braid_wrapper.hpp	/^        Network*   network;    \/* Pointer to the DNN Network Block (local layer storage) *\/$/;"	m	class:myBraidApp
networkType	include/config.hpp	/^enum networkType{DENSE, CONVOLUTIONAL}; $/;"	g
network_type	include/config.hpp	/^      int    network_type;$/;"	m	class:Config
new_iterations	xbraid/misc/user_utils/cycleplot.py	/^      new_iterations = (level == maxl).nonzero()[0]$/;"	v
new_iterations	xbraid/misc/user_utils/cycleplot.py	/^      new_iterations = new_iterations[ ((new_iterations[1:] - new_iterations[:-1]) != 1).nonzero()[0] ]$/;"	v
newconfigfile	examples/mnist/mnist_runs/submit_paramstudy.py	/^            newconfigfile = jobname + ".cfg"$/;"	v
newconfigfile	pythonutil/submit_paramstudy.py	/^            newconfigfile = jobname + ".cfg"$/;"	v
next	xbraid/braid/_braid_tape.h	/^    struct _braid_tape_struct *next;$/;"	m	struct:_braid_tape_struct	typeref:struct:_braid_tape_struct::_braid_tape_struct
nfeatures	include/config.hpp	/^      int nfeatures;$/;"	m	class:Config
nfeatures	include/dataset.hpp	/^      int nfeatures;         \/* Number of features per element *\/$/;"	m	class:DataSet
nfmg	xbraid/braid/_braid.h	/^   braid_Int              nfmg;             \/**< number of fmg cycles to do initially before switching to V-cycles *\/$/;"	m	struct:_braid_Core_struct
nfmg	xbraid/drivers/braid_mfem_block.hpp	/^    int  nfmg;$/;"	m	struct:BraidOptions
nfmg_Vcyc	xbraid/braid/_braid.h	/^   braid_Int              nfmg_Vcyc;        \/**< number of V-cycle calls at each level in FMG *\/$/;"	m	struct:_braid_Core_struct
nfmg_Vcyc	xbraid/drivers/braid_mfem.hpp	/^   int    nfmg_Vcyc;$/;"	m	struct:BraidOptions
nfmg_Vcyc	xbraid/drivers/braid_mfem_block.hpp	/^    int  nfmg_Vcyc;$/;"	m	struct:BraidOptions
nfmg_Vcyc	xbraid/examples/ex-01-expanded-f.f90	/^   integer min_coarse, print_level, access_level, nfmg_Vcyc,/;"	v	program:ex01_f90
niter	xbraid/braid/_braid.h	/^   braid_Int              niter;            \/**< number of iterations *\/$/;"	m	struct:_braid_Core_struct
niter	xbraid/misc/user_utils/cycleplot.py	/^         niter   = data[:,2].max()$/;"	v
niter	xbraid/misc/user_utils/cycleplot.py	/^         niter   = max(niter_max, data[:,2].max())$/;"	v
niter_max	xbraid/misc/user_utils/cycleplot.py	/^      niter_max = 12$/;"	v
niter_max	xbraid/misc/user_utils/cycleplot.py	/^      niter_max = int(argv[2])$/;"	v
nlabels	include/dataset.hpp	/^      int nlabels;           \/* Number of different labels (i.e. classes) per element *\/$/;"	m	class:DataSet
nlayers	include/config.hpp	/^      int    nlayers;$/;"	m	class:Config
nlayers_global	include/network.hpp	/^      int     nlayers_global;       \/* Total number of Layers of the network *\/$/;"	m	class:Network
nlayers_local	include/network.hpp	/^      int     nlayers_local;        \/* Number of Layers in this network block *\/$/;"	m	class:Network
nlevel_max	xbraid/misc/user_utils/cycleplot.py	/^      nlevel_max = 5$/;"	v
nlevel_max	xbraid/misc/user_utils/cycleplot.py	/^      nlevel_max = int(argv[3])$/;"	v
nlevels	xbraid/braid/_braid.h	/^   braid_Int              nlevels;          \/**< number of temporal grid levels *\/$/;"	m	struct:_braid_Core_struct
nlevels	xbraid/misc/user_utils/cycleplot.py	/^         nlevels = data[:,0].max() - data[:,0].min()$/;"	v
nlevels	xbraid/misc/user_utils/cycleplot.py	/^         nlevels = max(nlevel_max, data[:,0].max() - data[:,0].min())$/;"	v
npt	examples/mnist/mnist_runs/submit_paramstudy.py	/^npt = 2 # number of processors$/;"	v
npt	pythonutil/submit_paramstudy.py	/^npt = 2 # number of processors$/;"	v
nptlist	testing/testing.py	/^nptlist  = args.nprocs$/;"	v
nrdefault	xbraid/braid/_braid.h	/^   braid_Int              nrdefault;        \/**< default number of pre-relaxations *\/$/;"	m	struct:_braid_Core_struct
nrefine	xbraid/braid/_braid.h	/^   braid_Int              nrefine;          \/**< number of refinements done *\/$/;"	m	struct:_braid_Core_struct
nrefine	xbraid/braid/_braid_tape.h	/^   braid_Int         nrefine;          \/**< number of refinements done *\/$/;"	m	struct:_braid_Action_struct
nrelax	xbraid/drivers/braid_mfem.hpp	/^   int    nrelax;$/;"	m	struct:BraidOptions
nrelax	xbraid/drivers/braid_mfem_block.hpp	/^    int  nrelax;$/;"	m	struct:BraidOptions
nrelax	xbraid/examples/ex-01-expanded-f.f90	/^   integer ierr, rc, max_levels, nrelax,/;"	v	program:ex01_f90
nrelax0	xbraid/drivers/braid_mfem.hpp	/^   int    nrelax0;$/;"	m	struct:BraidOptions
nrelax0	xbraid/drivers/braid_mfem_block.hpp	/^    int  nrelax0;$/;"	m	struct:BraidOptions
nrelax0	xbraid/examples/ex-01-expanded-f.f90	/^   integer ierr, rc, max_levels, nrelax, nrelax0,/;"	v	program:ex01_f90
nrels	xbraid/braid/_braid.h	/^   braid_Int             *nrels;            \/**< number of pre-relaxations on each level *\/$/;"	m	struct:_braid_Core_struct
nspace	xbraid/drivers/viz-burgers-1D.py	/^nspace = int(data[3])$/;"	v
nspace	xbraid/examples/viz-ex-02.py	/^nspace = int(data[3])$/;"	v
nsteps	xbraid/drivers/viz-burgers-1D.py	/^nsteps = int(data[0])$/;"	v
nsteps	xbraid/examples/viz-ex-02.py	/^nsteps = int(data[0])$/;"	v
nsteps	xbraid/examples/viz-ex-04.py	/^nsteps = design.shape[0]$/;"	v
ntime	xbraid/braid/_braid.h	/^   braid_Int              ntime;            \/**< initial number of time intervals *\/$/;"	m	struct:_braid_Core_struct
ntime	xbraid/braid/braid.hpp	/^   braid_Int    ntime;$/;"	m	class:BraidApp
ntime	xbraid/examples/ex-01-expanded-f.f90	/^      integer                       :: ntime$/;"	k	type:my_app
ntime	xbraid/examples/ex-01-expanded-f.f90	/^   integer mydt, ntime,/;"	v	program:ex01_f90
ntraining	include/config.hpp	/^      int ntraining;$/;"	m	class:Config
num_procs_x	xbraid/drivers/braid_mfem.hpp	/^   int    num_procs_x;$/;"	m	struct:BraidOptions
num_procs_x	xbraid/drivers/braid_mfem_block.hpp	/^    int  num_procs_x;$/;"	m	struct:BraidOptions
num_requests	xbraid/braid/_braid.h	/^   braid_Int         num_requests;    \/**< number of active requests for this handle, usually 1 *\/$/;"	m	struct:__anon2
num_time_steps	xbraid/drivers/braid_mfem.hpp	/^   int    num_time_steps;$/;"	m	struct:BraidOptions
num_time_steps	xbraid/drivers/braid_mfem_block.hpp	/^    int  num_time_steps;$/;"	m	struct:BraidOptions
numarg	xbraid/examples/ex-01-expanded-f.f90	/^   integer max_iter, fmg, wrapper_tests, print_help, i, numarg$/;"	v	program:ex01_f90
nupoints	xbraid/braid/_braid.h	/^   braid_Int          nupoints;      \/**< number of unknown vector points *\/$/;"	m	struct:__anon3
nvalidation	include/config.hpp	/^      int nvalidation;$/;"	m	class:Config
nweights	include/layer.hpp	/^      int nweights;                        \/* Number of weights *\/$/;"	m	class:Layer
objT_diff	xbraid/braid/_braid.h	/^   braid_PtFcnObjectiveTDiff            objT_diff;            \/**< User function: apply differentiated objective function *\/$/;"	m	struct:_braid_Core_struct
obj_only	xbraid/braid/_braid.h	/^   braid_Int              obj_only;          \/**< determines if adjoint code computes ONLY objective, no gradients. *\/$/;"	m	struct:_braid_Core_struct
objective	include/braid_wrapper.hpp	/^        MyReal objective;       \/* Objective function *\/$/;"	m	class:myBraidApp
objective	xbraid/braid/_braid.h	/^   braid_Real       objective;        \/**< global objective function value *\/$/;"	m	struct:_braid_Optimization_struct
objectiveT	xbraid/braid/_braid.h	/^   braid_PtFcnObjectiveT                objectiveT;           \/**< User function: evaluate objective function at time t *\/$/;"	m	struct:_braid_Core_struct
ode	xbraid/drivers/braid_mfem.hpp	/^   Array<TimeDependentOperator *> ode;$/;"	m	class:MFEMBraidApp
ode	xbraid/drivers/braid_mfem_block.hpp	/^    Array<TimeDependentOperator *> ode;$/;"	m	class:MFEMBraidApp
old_fine_tolx	xbraid/braid/_braid.h	/^   braid_Real    old_fine_tolx;    \/**< Allows for storing the previously used fine tolerance from GetSpatialAccuracy *\/$/;"	m	struct:_braid_Core_struct
openlayer	include/network.hpp	/^      Layer*  openlayer;            \/* At first processor: openinglayer, else: NULL *\/$/;"	m	class:Network
openlayer_type	include/config.hpp	/^      int    openlayer_type;$/;"	m	class:Config
operator =	xbraid/drivers/braid_mfem.hpp	/^   BraidVector &operator=(const Vector &source_vector)$/;"	f	class:BraidVector
operator =	xbraid/drivers/braid_mfem.hpp	/^   BraidVector &operator=(double value)$/;"	f	class:BraidVector
operator =	xbraid/drivers/braid_mfem_block.hpp	/^    BraidVector &operator=(const BlockVector &source_vector)$/;"	f	class:BraidVector
optim	xbraid/braid/_braid.h	/^   braid_Optim            optim;             \/**< structure that stores optimization variables (objective function, etc.) *\/ $/;"	m	struct:_braid_Core_struct
ordered_bunchify	pythonutil/ordered_bunch.py	/^def ordered_bunchify(x):$/;"	f
ordered_unbunchify	pythonutil/ordered_bunch.py	/^def ordered_unbunchify(x):$/;"	f
outTime	xbraid/braid/_braid_tape.h	/^   braid_Real        outTime;          \/**< time of the output vector *\/$/;"	m	struct:_braid_Action_struct
outfile	testing/testing.py	/^outfile = "optim.dat"$/;"	v
own_data	xbraid/drivers/braid_mfem.hpp	/^   bool own_data;$/;"	m	class:MFEMBraidApp
own_data	xbraid/drivers/braid_mfem_block.hpp	/^    bool own_data;$/;"	m	class:MFEMBraidApp
par_ref_levels	xbraid/drivers/braid_mfem.hpp	/^   int         par_ref_levels;$/;"	m	struct:BraidOptions
par_ref_levels	xbraid/drivers/braid_mfem_block.hpp	/^    int   par_ref_levels;$/;"	m	struct:BraidOptions
params	xbraid/misc/user_utils/cycleplot.py	/^      params = return_rcparams(fig_width=fig_size[0], fig_height=fig_size[1], fontfamily='serif', fontsize=fontsize)$/;"	v
parser	testing/testing.py	/^parser = argparse.ArgumentParser()$/;"	v
pop	pythonutil/ordered_dict.py	/^    def pop(self, key, default=__marker):$/;"	m	class:OrderedDict
popitem	pythonutil/ordered_dict.py	/^    def popitem(self, last=True):$/;"	m	class:OrderedDict
postprocess_obj	xbraid/braid/_braid.h	/^   braid_PtFcnPostprocessObjective      postprocess_obj;      \/**< Optional user function: Modify the time-averaged objective function, e.g. for inverse design problems, adding relaxation term etc. *\/$/;"	m	struct:_braid_Core_struct
postprocess_obj_diff	xbraid/braid/_braid.h	/^   braid_PtFcnPostprocessObjective_diff postprocess_obj_diff; \/**< Optional user function: Derivative of postprocessing function  *\/$/;"	m	struct:_braid_Core_struct
prev	include/config.hpp	/^         struct config_option* prev;$/;"	m	struct:Config::config_option	typeref:struct:Config::config_option::config_option
primalcore	include/braid_wrapper.hpp	/^        BraidCore* primalcore; \/* pointer to primal core for accessing primal states *\/$/;"	m	class:myAdjointBraidApp
print_help	xbraid/examples/ex-01-expanded-f.f90	/^   integer max_iter, fmg, wrapper_tests, print_help,/;"	v	program:ex01_f90
print_level	xbraid/braid/_braid.h	/^   braid_Int              print_level;      \/**< determines amount of output printed to screen (0,1,2,3) *\/$/;"	m	struct:_braid_Core_struct
print_level	xbraid/drivers/braid_mfem.hpp	/^   int    print_level;$/;"	m	struct:BraidOptions
print_level	xbraid/drivers/braid_mfem_block.hpp	/^    int  print_level;$/;"	m	struct:BraidOptions
print_level	xbraid/examples/ex-01-expanded-f.f90	/^   integer min_coarse, print_level,/;"	v	program:ex01_f90
print_timegrid	xbraid/examples/ex-01-expanded-f.f90	/^subroutine print_timegrid(/;"	s
probability	include/layer.hpp	/^            MyReal* probability;          \/* vector of pedicted class probabilities *\/$/;"	m	class:ClassificationLayer
pstatus	xbraid/braid/braid.hpp	/^      braid_StepStatus pstatus;$/;"	m	class:BraidStepStatus
r	xbraid/misc/user_utils/cycleplot.py	/^      r = data[:,4]$/;"	v
r_indices	xbraid/misc/user_utils/cycleplot.py	/^         r_indices = setdiff1d((dr != 0).nonzero()[0], (r==0).nonzero()[0]-1)  # x-locations to print$/;"	v
r_level	xbraid/misc/user_utils/cycleplot.py	/^         r_level = level[r_indices]         # corresponding level numbers$/;"	v
r_space	xbraid/braid/_braid.h	/^   braid_Int              r_space;          \/**< spatial refinment flag *\/$/;"	m	struct:_braid_Core_struct
r_to_print	xbraid/misc/user_utils/cycleplot.py	/^         r_to_print = r[r_indices+1]$/;"	v
rank	xbraid/drivers/viz-burgers-1D.py	/^rank = 0 #int(sys.argv[1])$/;"	v
rank	xbraid/examples/ex-01-expanded-f.f90	/^      integer                       :: rank$/;"	k	type:my_app
rank	xbraid/examples/ex-01-expanded-f.f90	/^   integer mydt, ntime, rank$/;"	v	program:ex01_f90
rc	xbraid/examples/ex-01-expanded-f.f90	/^   integer ierr, rc,/;"	v	program:ex01_f90
read	pythonutil/config.py	/^    def read(self,filename):$/;"	m	class:Config
read_config	pythonutil/config.py	/^def read_config(filename):$/;"	f
record	xbraid/braid/_braid.h	/^   braid_Int              record;            \/**< determines if actions are recorded to the tape or not.  This separate $/;"	m	struct:_braid_Core_struct
recv_handle	xbraid/braid/_braid.h	/^   _braid_CommHandle *recv_handle;   \/**<  Handle for nonblocking receives of braid_BaseVectors *\/$/;"	m	struct:__anon3
recv_index	xbraid/braid/_braid.h	/^   braid_Int          recv_index;    \/**<  -1 means no receive *\/$/;"	m	struct:__anon3
refine	xbraid/braid/_braid.h	/^   braid_Int              refine;           \/**< refine in time (refine = 1) *\/$/;"	m	struct:_braid_Core_struct
refname	testing/testing.py	/^        refname = testname  + "." + outfile $/;"	v
replace	xbraid/examples/ex-01-expanded-f.f90	/^subroutine replace(/;"	s
request	xbraid/braid/_braid.h	/^   MPI_Request     *request;          \/**< helper: Storing the MPI request of BufUnPackDiff *\/$/;"	m	struct:_braid_Optimization_struct
request_type	xbraid/braid/_braid.h	/^   braid_Int         request_type;    \/**< two values: recv type = 1, and send type = 0 *\/$/;"	m	struct:__anon2
requests	xbraid/braid/_braid.h	/^   MPI_Request      *requests;        \/**< MPI request structure *\/$/;"	m	struct:__anon2
res	xbraid/drivers/braid_mfem_block.hpp	/^    int  res;$/;"	m	struct:BraidOptions
res	xbraid/examples/ex-01-expanded-f.f90	/^   integer min_coarse, print_level, access_level, nfmg_Vcyc, res$/;"	v	program:ex01_f90
reset_gradient	xbraid/braid/_braid.h	/^   braid_PtFcnResetGradient             reset_gradient;       \/**< User function: Set the gradient to zero. Is called before each iteration *\/$/;"	m	struct:_braid_Core_struct
residual	xbraid/braid/_braid.h	/^   braid_PtFcnResidual    residual;         \/**< (optional) compute residual *\/$/;"	m	struct:_braid_Core_struct
return_rcparams	xbraid/misc/user_utils/cycleplot.py	/^def return_rcparams(fig_width=5, fig_height=5, fontsize=28, fontfamily='sans-serif'):$/;"	f
reverted_ranks	xbraid/braid/_braid.h	/^   braid_Int              reverted_ranks;    $/;"	m	struct:_braid_Core_struct
rfactor	xbraid/braid/_braid.h	/^   braid_Int     rfactor;          \/**< if set by user, allows for subdivision of this interval for better time accuracy *\/$/;"	m	struct:_braid_Core_struct
rfactors	xbraid/braid/_braid.h	/^   braid_Int             *rfactors;         \/**< refinement factors for finest grid (if any) *\/$/;"	m	struct:_braid_Core_struct
rho	include/hessianApprox.hpp	/^      MyReal*  rho;           \/* storing M 1\/y^Ts values *\/$/;"	m	class:L_BFGS
rnorm	xbraid/braid/_braid.h	/^   braid_Real       rnorm;            \/**< norm of the state residual *\/$/;"	m	struct:_braid_Optimization_struct
rnorm	xbraid/braid/_braid.h	/^   braid_Real    rnorm;            \/**< residual norm *\/$/;"	m	struct:_braid_Core_struct
rnorm	xbraid/misc/user_utils/cycleplot.py	/^         rnorm = -1$/;"	v
rnorm	xbraid/misc/user_utils/cycleplot.py	/^         rnorm = data[:,4]$/;"	v
rnorm0	xbraid/braid/_braid.h	/^   braid_Real             rnorm0;           \/**< initial residual norm *\/$/;"	m	struct:_braid_Core_struct
rnorm0	xbraid/braid/_braid.h	/^   braid_Real       rnorm0;           \/**< initial norm of the state residual *\/$/;"	m	struct:_braid_Optimization_struct
rnorm0_adj	xbraid/braid/_braid.h	/^   braid_Real       rnorm0_adj;       \/**< initial norm of the adjoint residual *\/$/;"	m	struct:_braid_Optimization_struct
rnorm_adj	xbraid/braid/_braid.h	/^   braid_Real       rnorm_adj;        \/**< norm of the adjoint residual *\/$/;"	m	struct:_braid_Optimization_struct
rnorms	xbraid/braid/_braid.h	/^   braid_Real            *rnorms;           \/**< residual norm history *\/$/;"	m	struct:_braid_Core_struct
rstopped	xbraid/braid/_braid.h	/^   braid_Int              rstopped;         \/**< refinement stopped at iteration rstopped *\/$/;"	m	struct:_braid_Core_struct
rtol	xbraid/braid/_braid.h	/^   braid_Int              rtol;             \/**< use relative tolerance *\/$/;"	m	struct:_braid_Core_struct
rtol	xbraid/drivers/braid_mfem.hpp	/^   bool   rtol;$/;"	m	struct:BraidOptions
rtol_adj	xbraid/braid/_braid.h	/^   braid_Int        rtol_adj;         \/**< flag: use relative tolerance for adjoint *\/$/;"	m	struct:_braid_Optimization_struct
runcommand	examples/mnist/mnist_runs/submit_paramstudy.py	/^runcommand = "mpirun -n"$/;"	v
runcommand	pythonutil/submit_paramstudy.py	/^runcommand = "mpirun -n"$/;"	v
runcommand	testing/testing.py	/^        runcommand = "mpirun -n " + str(npt) + " ..\/..\/main " + testconfig + " > tmp"$/;"	v
s	include/hessianApprox.hpp	/^      MyReal* s;          $/;"	m	class:BFGS
s	include/hessianApprox.hpp	/^      MyReal** s;             \/* storing M (x_{k+1} - x_k) vectors *\/$/;"	m	class:L_BFGS
sclone	xbraid/braid/_braid.h	/^   braid_PtFcnSClone      sclone;           \/**< (optional) clone the shell of a vector *\/$/;"	m	struct:_braid_Core_struct
scoarsen	xbraid/braid/_braid.h	/^   braid_PtFcnSCoarsen    scoarsen;         \/**< (optional) return a spatially coarsened vector *\/$/;"	m	struct:_braid_Core_struct
send_handle	xbraid/braid/_braid.h	/^   _braid_CommHandle *send_handle;   \/**<  Handle for nonblocking sends of braid_BaseVectors *\/$/;"	m	struct:__anon3
send_index	xbraid/braid/_braid.h	/^   braid_Int          send_index;    \/**<  -1 means no send *\/$/;"	m	struct:__anon3
send_recv_rank	xbraid/braid/_braid.h	/^   braid_Int    send_recv_rank;    \/***< holds the rank of the source \/ receiver from MPI_Send \/ MPI_Recv calls. *\/$/;"	m	struct:_braid_Core_struct
send_recv_rank	xbraid/braid/_braid_tape.h	/^   braid_Int         send_recv_rank;   \/**< processor rank of sender \/ receiver in my_bufpack \/ my_bufunpack *\/$/;"	m	struct:_braid_Action_struct
sendbuffer	xbraid/braid/_braid.h	/^   void            *sendbuffer;       \/**< helper: Memory for BufUnPackDiff communication *\/$/;"	m	struct:_braid_Optimization_struct
sendflag	include/braid_wrapper.hpp	/^        MyReal sendflag;  $/;"	m	class:myBraidVector
seq_soln	xbraid/braid/_braid.h	/^   braid_Int              seq_soln;         \/**< boolean, controls if the initial guess is from sequential time stepping*\/$/;"	m	struct:_braid_Core_struct
ser_ref_levels	xbraid/drivers/braid_mfem.hpp	/^   int         ser_ref_levels;$/;"	m	struct:BraidOptions
ser_ref_levels	xbraid/drivers/braid_mfem_block.hpp	/^    int   ser_ref_levels;$/;"	m	struct:BraidOptions
setdefault	pythonutil/ordered_dict.py	/^    def setdefault(self, key, default=None):$/;"	m	class:OrderedDict
sfree	xbraid/braid/_braid.h	/^   braid_PtFcnSFree       sfree;            \/**< (optional) free up the data of a vector, keep the shell *\/$/;"	m	struct:_braid_Core_struct
sinit	xbraid/braid/_braid.h	/^   braid_PtFcnSInit       sinit;            \/**< (optional) return an initialized shell of braid_BaseVector *\/$/;"	m	struct:_braid_Core_struct
size	xbraid/braid/_braid_tape.h	/^    int size;$/;"	m	struct:_braid_tape_struct
size_buffer	xbraid/braid/_braid.h	/^   braid_Int    size_buffer;       \/**< if set by user, send buffer will be "size" bytes in length *\/$/;"	m	struct:_braid_Core_struct
size_buffer	xbraid/braid/_braid_tape.h	/^   braid_Int         size_buffer;      \/**< if set by user, size of send buffer is "size" bytes *\/$/;"	m	struct:_braid_Action_struct
sizeof_double	xbraid/examples/ex-01-expanded-f.f90	/^   integer, parameter :: sizeof_double /;"	v	module:braid_types
sizeof_int	xbraid/examples/ex-01-expanded-f.f90	/^   integer, parameter :: sizeof_int /;"	v	module:braid_types
skip	xbraid/braid/_braid.h	/^   braid_Int              skip;             \/**< boolean, controls skipping any work on first down-cycle *\/$/;"	m	struct:_braid_Core_struct
skip	xbraid/drivers/braid_mfem.hpp	/^   int    skip;$/;"	m	struct:BraidOptions
skip	xbraid/drivers/braid_mfem_block.hpp	/^    int  skip;$/;"	m	struct:BraidOptions
sol_sock	xbraid/drivers/braid_mfem.hpp	/^   socketstream sol_sock;$/;"	m	class:MFEMBraidApp
sol_sock	xbraid/drivers/braid_mfem_block.hpp	/^    socketstream sol_sock;$/;"	m	class:MFEMBraidApp
solver	xbraid/drivers/braid_mfem.hpp	/^   Array<ODESolver *>        solver;$/;"	m	class:MFEMBraidApp
solver	xbraid/drivers/braid_mfem_block.hpp	/^    Array<ODESolver *>      solver;$/;"	m	class:MFEMBraidApp
spatial_coarsen	xbraid/drivers/braid_mfem.hpp	/^   bool   spatial_coarsen;$/;"	m	struct:BraidOptions
spatial_coarsen	xbraid/drivers/braid_mfem_block.hpp	/^    bool    spatial_coarsen;$/;"	m	struct:BraidOptions
spatial_level	xbraid/drivers/braid_mfem_block.hpp	/^    int spatial_level;$/;"	m	class:BraidVector
spatialnorm	xbraid/braid/_braid.h	/^   braid_PtFcnSpatialNorm spatialnorm;      \/**< Compute norm of a braid_BaseVector, this is a norm only over space *\/$/;"	m	struct:_braid_Core_struct
srefine	xbraid/braid/_braid.h	/^   braid_PtFcnSRefine     srefine;          \/**< (optional) return a spatially refined vector *\/$/;"	m	struct:_braid_Core_struct
startlayerID	include/network.hpp	/^      int     startlayerID;         \/* ID of the first layer on that processor *\/$/;"	m	class:Network
state	include/braid_wrapper.hpp	/^        MyReal **state;   \/* Network state at one layer, dimensions: nbatch * nchannels *\/$/;"	m	class:myBraidVector
state_vec	xbraid/examples/viz-ex-04.py	/^    state_vec = loadtxt('ex-04.out.state')$/;"	v
state_vec	xbraid/examples/viz-ex-04.py	/^    state_vec = zeros((nsteps,2))$/;"	v
status	xbraid/braid/_braid.h	/^   MPI_Status       *status;          \/**< MPI status *\/$/;"	m	struct:__anon2
status	xbraid/braid/_braid_status.h	/^   _braid_Status status;$/;"	m	struct:_braid_AccessStatus_struct
status	xbraid/braid/_braid_status.h	/^   _braid_Status status;$/;"	m	struct:_braid_BufferStatus_struct
status	xbraid/braid/_braid_status.h	/^   _braid_Status status;$/;"	m	struct:_braid_CoarsenRefStatus_struct
status	xbraid/braid/_braid_status.h	/^   _braid_Status status;$/;"	m	struct:_braid_ObjectiveStatus_struct
status	xbraid/braid/_braid_status.h	/^   _braid_Status status;$/;"	m	struct:_braid_StepStatus_struct
step	xbraid/braid/_braid.h	/^   braid_PtFcnStep        step;             \/**< apply step function *\/$/;"	m	struct:_braid_Core_struct
step	xbraid/drivers/viz-burgers-1D.py	/^step = 0$/;"	v
step	xbraid/examples/viz-ex-02.py	/^step = 0$/;"	v
step_diff	xbraid/braid/_braid.h	/^   braid_PtFcnStepDiff                  step_diff;            \/**< User function: apply differentiated step function *\/$/;"	m	struct:_braid_Core_struct
stepsize_init	include/config.hpp	/^      MyReal stepsize_init;$/;"	m	class:Config
stepsize_type	include/config.hpp	/^      int    stepsize_type;$/;"	m	class:Config
stepsizetype	include/config.hpp	/^enum stepsizetype{FIXED, BACKTRACKINGLS, ONEOVERK};$/;"	g
storage	xbraid/braid/_braid.h	/^   braid_Int              storage;          \/**< storage = 0 (C-points), = 1 (all) *\/$/;"	m	struct:_braid_Core_struct
storage	xbraid/drivers/braid_mfem.hpp	/^   int    storage;$/;"	m	struct:BraidOptions
storage	xbraid/drivers/braid_mfem_block.hpp	/^    int  storage;$/;"	m	struct:BraidOptions
submit_job	pythonutil/batch_job.py	/^def submit_job(jobname, runcommand, ntasks, time_limit, executable, arguments,run=True):$/;"	f
sum	xbraid/braid/_braid.h	/^   braid_PtFcnSum         sum;              \/**< vector sum *\/$/;"	m	struct:_braid_Core_struct
sum_alpha	xbraid/braid/_braid_tape.h	/^   braid_Real        sum_alpha;        \/**< first coefficient of my_sum *\/$/;"	m	struct:_braid_Action_struct
sum_beta	xbraid/braid/_braid_tape.h	/^   braid_Real        sum_beta;         \/**< second coefficient of my_sum *\/$/;"	m	struct:_braid_Action_struct
sum_user_obj	xbraid/braid/_braid.h	/^   braid_Real       sum_user_obj;     \/**< sum of user's objective function values over time *\/$/;"	m	struct:_braid_Optimization_struct
switch	pythonutil/switch.py	/^class switch(object):$/;"	c
t	xbraid/braid/_braid.h	/^   braid_Real    t;                \/**< current time *\/$/;"	m	struct:_braid_Core_struct
t	xbraid/examples/ex-01-expanded-f.f90	/^   double precision t,/;"	v	program:ex01_f90
t_final	xbraid/drivers/braid_mfem.hpp	/^   double t_final;$/;"	m	struct:BraidOptions
t_final	xbraid/drivers/braid_mfem_block.hpp	/^    double t_final;$/;"	m	struct:BraidOptions
t_start	xbraid/drivers/braid_mfem.hpp	/^   double t_start;$/;"	m	struct:BraidOptions
t_start	xbraid/drivers/braid_mfem_block.hpp	/^    double t_start;$/;"	m	struct:BraidOptions
ta	xbraid/braid/_braid.h	/^   braid_Real        *ta;            \/**< time values                (all points) *\/$/;"	m	struct:__anon3
ta_alloc	xbraid/braid/_braid.h	/^   braid_Real        *ta_alloc;      \/**< original memory allocation for ta *\/$/;"	m	struct:__anon3
tapeinput	xbraid/braid/_braid.h	/^   braid_VectorBar *tapeinput;        \/**< helper: store pointer to input of one braid iteration *\/$/;"	m	struct:_braid_Optimization_struct
testconfig	testing/testing.py	/^        testconfig = testname + ".cfg"$/;"	v
testfoldername	testing/testing.py	/^        testfoldername = "test." + testname$/;"	v
testname	testing/testing.py	/^        testname = case + ".npt" + str(npt) + ".ml" + str(ml) $/;"	v
tgrid	xbraid/braid/_braid.h	/^   braid_PtFcnTimeGrid    tgrid;            \/**< (optional) return time point values on level 0 *\/$/;"	m	struct:_braid_Core_struct
tight_fine_tolx	xbraid/braid/_braid.h	/^   braid_Int     tight_fine_tolx;  \/**< Boolean, indicating whether the tightest fine tolx has been used, condition for halting *\/$/;"	m	struct:_braid_Core_struct
tmesh	xbraid/examples/viz-ex-04.py	/^tmesh = linspace(0,1.0,nsteps+1)$/;"	v
tnext	xbraid/braid/_braid.h	/^   braid_Real    tnext;            \/**< time value to evolve towards, time value to the right of tstart *\/$/;"	m	struct:_braid_Core_struct
tnorm	xbraid/braid/_braid.h	/^   braid_Int              tnorm;            \/**< choice of temporal norm *\/$/;"	m	struct:_braid_Core_struct
tnorm	xbraid/drivers/braid_mfem.hpp	/^   int    tnorm;$/;"	m	struct:BraidOptions
tnorm	xbraid/drivers/braid_mfem_block.hpp	/^    int  tnorm;$/;"	m	struct:BraidOptions
tnorm_a	xbraid/braid/_braid.h	/^   braid_Real            *tnorm_a;          \/**< local array of residual norms on a proc's interval, used for inf-norm *\/$/;"	m	struct:_braid_Core_struct
toJSON	pythonutil/ordered_bunch.py	/^    def toJSON(self, **options):$/;"	f	function:ordered_unbunchify
toOrderedDict	pythonutil/ordered_bunch.py	/^    def toOrderedDict(self):$/;"	m	class:OrderedBunch
toYAML	pythonutil/ordered_bunch.py	/^    def toYAML(self, **options):$/;"	f
to_yaml	pythonutil/ordered_bunch.py	/^    def to_yaml(dumper, data):$/;"	f
to_yaml_safe	pythonutil/ordered_bunch.py	/^    def to_yaml_safe(dumper, data):$/;"	f
todo : Don't feed applyBWD with NULL! */	src/braid_wrapper.cpp	/^            \/* TODO: Don't feed applyBWD with NULL! *\/$/;"	t
todo : Fix	src/network.cpp	/^                \/\/ TODO: Fix$/;"	t
todo : Remove these two lines, which are now useless since core==status */	xbraid/braid/_braid.c	/^         \/* TODO : Remove these two lines, which are now useless since core==status *\/$/;"	t
todo : read some design */	src/main.cpp	/^        \/* TODO: read some design *\/$/;"	t
todo : so something, if design is part of  initial conditions!!  */	xbraid/braid/_braid_tape.c	/^         \/* TODO: so something, if design is part of  initial conditions!!  *\/$/;"	t
todo Remove this line after modifing the _braid_StatusSetRFactor to set the rfactor in the array directly */	xbraid/braid/_braid.c	/^         \/*TODO Remove this line after modifing the _braid_StatusSetRFactor to set the rfactor in the array directly *\/$/;"	t
tol	xbraid/braid/_braid.h	/^   braid_Real             tol;              \/**< stopping tolerance *\/$/;"	m	struct:_braid_Core_struct
tol	xbraid/braid/_braid_tape.h	/^   braid_Real        tol;              \/**< primal stopping tolerance *\/      $/;"	m	struct:_braid_Action_struct
tol	xbraid/drivers/braid_mfem.hpp	/^   double tol;$/;"	m	struct:BraidOptions
tol	xbraid/drivers/braid_mfem_block.hpp	/^    double tol;$/;"	m	struct:BraidOptions
tol	xbraid/examples/ex-01-expanded-f.f90	/^   double precision t, tol,/;"	v	program:ex01_f90
tol	xbraid/misc/user_utils/cycleplot.py	/^         tol = data[:,5]$/;"	v
tol_adj	xbraid/braid/_braid.h	/^   braid_Real       tol_adj;          \/**< tolerance of adjoint residual *\/$/;"	m	struct:_braid_Optimization_struct
tols	xbraid/misc/user_utils/cycleplot.py	/^         tols = data[:,5]$/;"	v
tpoints_cutoff	xbraid/braid/_braid.h	/^   braid_Int              tpoints_cutoff;   \/**< refinements halt after the number of time steps exceed this value *\/$/;"	m	struct:_braid_Core_struct
tstart	xbraid/braid/_braid.h	/^   braid_Real             tstart;           \/**< start time *\/$/;"	m	struct:_braid_Core_struct
tstart	xbraid/braid/braid.hpp	/^   braid_Real   tstart;$/;"	m	class:BraidApp
tstart	xbraid/drivers/viz-burgers-1D.py	/^tstart = float(data[1])$/;"	v
tstart	xbraid/examples/ex-01-expanded-f.f90	/^      double precision              :: tstart$/;"	k	type:my_app
tstart	xbraid/examples/ex-01-expanded-f.f90	/^   double precision t, tol, tstart,/;"	v	program:ex01_f90
tstart	xbraid/examples/viz-ex-02.py	/^tstart = float(data[1])$/;"	v
tstart_obj	xbraid/braid/_braid.h	/^   braid_Real       tstart_obj;       \/**< starting time for evaluating the user's local objective *\/$/;"	m	struct:_braid_Optimization_struct
tstop	xbraid/braid/_braid.h	/^   braid_Real             tstop;            \/**< stop time *\/$/;"	m	struct:_braid_Core_struct
tstop	xbraid/braid/braid.hpp	/^   braid_Real   tstop;$/;"	m	class:BraidApp
tstop	xbraid/drivers/viz-burgers-1D.py	/^tstop = float(data[2])$/;"	v
tstop	xbraid/examples/ex-01-expanded-f.f90	/^      double precision              :: tstop$/;"	k	type:my_app
tstop	xbraid/examples/ex-01-expanded-f.f90	/^   double precision t, tol, tstart, tstop$/;"	v	program:ex01_f90
tstop	xbraid/examples/viz-ex-02.py	/^tstop = float(data[2])$/;"	v
tstop_obj	xbraid/braid/_braid.h	/^   braid_Real       tstop_obj;        \/**< stopping time for evaluating the user's local objective *\/$/;"	m	struct:_braid_Optimization_struct
type	include/layer.hpp	/^      int     type;                        \/* Type of the layer (enum element) *\/$/;"	m	class:Layer
ua	xbraid/braid/_braid.h	/^   braid_BaseVector  *ua;            \/**< unknown vectors            (C-points at least)*\/$/;"	m	struct:__anon3
ua_alloc	xbraid/braid/_braid.h	/^   braid_BaseVector  *ua_alloc;      \/**< original memory allocation for ua *\/$/;"	m	struct:__anon3
ulast	xbraid/braid/_braid.h	/^   braid_BaseVector ulast;          \/**< stores last time step *\/$/;"	m	struct:__anon3
update	include/layer.hpp	/^      MyReal *update;                      \/* Auxilliary for computing fwd update *\/$/;"	m	class:Layer
update	pythonutil/ordered_dict.py	/^    def update(*args, **kwds):$/;"	m	class:OrderedDict
update_bar	include/layer.hpp	/^      MyReal *update_bar;                  \/* Auxilliary for computing bwd update *\/$/;"	m	class:Layer
useCount	xbraid/braid/_braid.h	/^   braid_Int    useCount;           \/**< counts the number of pointers to this struct *\/$/;"	m	struct:_braid_VectorBar_struct
use_seq_soln	xbraid/drivers/braid_mfem.hpp	/^   int    use_seq_soln;$/;"	m	struct:BraidOptions
userVector	xbraid/braid/_braid.h	/^   braid_Vector    userVector;      \/**< holds the users primal vector *\/$/;"	m	struct:_braid_BaseVector_struct
userVector	xbraid/braid/_braid.h	/^   braid_Vector userVector;         \/**< holds the u_bar data *\/$/;"	m	struct:_braid_VectorBar_struct
userVectorTape	xbraid/braid/_braid.h	/^   _braid_Tape*          userVectorTape;     \/**< tape storing primal braid_vectors while recording *\/$/;"	m	struct:_braid_Core_struct
useshell	xbraid/braid/_braid.h	/^   braid_Int              useshell;         \/**< activate the shell structure of vectors *\/$/;"	m	struct:_braid_Core_struct
v	xbraid/drivers/braid_mfem_block.hpp	/^    Array<ParGridFunction *>  v;        \/\/ auxiliary ParGridFunctions for block v$/;"	m	class:MFEMBraidApp
va	xbraid/braid/_braid.h	/^   braid_BaseVector  *va;            \/**< restricted unknown vectors (all points, NULL on level 0) *\/$/;"	m	struct:__anon3
va_alloc	xbraid/braid/_braid.h	/^   braid_BaseVector  *va_alloc;      \/**< original memory allocation for va *\/$/;"	m	struct:__anon3
val	xbraid/examples/ex-01-expanded-f.f90	/^      double precision val$/;"	k	type:my_vector
validationlevel	include/config.hpp	/^      int    validationlevel;$/;"	m	class:Config
value	include/config.hpp	/^         char value[CONFIG_ARG_MAX_BYTES];$/;"	m	struct:Config::config_option
values	pythonutil/ordered_dict.py	/^    def values(self):$/;"	m	class:OrderedDict
vector_ptr	xbraid/braid/_braid.h	/^   braid_BaseVector *vector_ptr;      \/**< braid_vector being sent\/received *\/$/;"	m	struct:__anon2
verbose_adj	xbraid/braid/_braid.h	/^   braid_Int              verbose_adj;       \/**< verbosity of the adjoint tape, displays the actions that are pushed \/ popped to the tape*\/$/;"	m	struct:_braid_Core_struct
viewitems	pythonutil/ordered_dict.py	/^    def viewitems(self):$/;"	m	class:OrderedDict
viewkeys	pythonutil/ordered_dict.py	/^    def viewkeys(self):$/;"	m	class:OrderedDict
viewvalues	pythonutil/ordered_dict.py	/^    def viewvalues(self):$/;"	m	class:OrderedDict
vis_braid_steps	xbraid/drivers/braid_mfem.hpp	/^   int vis_braid_steps;$/;"	m	class:MFEMBraidApp
vis_braid_steps	xbraid/drivers/braid_mfem_block.hpp	/^    int vis_braid_steps;$/;"	m	class:MFEMBraidApp
vis_screenshots	xbraid/drivers/braid_mfem.hpp	/^   bool vis_screenshots;$/;"	m	class:MFEMBraidApp
vis_screenshots	xbraid/drivers/braid_mfem_block.hpp	/^    bool vis_screenshots;$/;"	m	class:MFEMBraidApp
vis_time_steps	xbraid/drivers/braid_mfem.hpp	/^   int vis_time_steps;$/;"	m	class:MFEMBraidApp
vis_time_steps	xbraid/drivers/braid_mfem_block.hpp	/^    int vis_time_steps;$/;"	m	class:MFEMBraidApp
vishost	xbraid/drivers/braid_mfem.hpp	/^   const char  *vishost;$/;"	m	class:MFEMBraidApp
vishost	xbraid/drivers/braid_mfem_block.hpp	/^    const char  *vishost;$/;"	m	class:MFEMBraidApp
vishost_default	xbraid/drivers/braid_mfem.hpp	/^   static const char *vishost_default;$/;"	m	class:MFEMBraidApp
vishost_default	xbraid/drivers/braid_mfem.hpp	/^const char *MFEMBraidApp::vishost_default = "localhost";$/;"	m	class:MFEMBraidApp
vishost_default	xbraid/drivers/braid_mfem_block.hpp	/^    static const char *vishost_default;$/;"	m	class:MFEMBraidApp
vishost_default	xbraid/drivers/braid_mfem_block.hpp	/^const char *MFEMBraidApp::vishost_default = "localhost";$/;"	m	class:MFEMBraidApp
visport	xbraid/drivers/braid_mfem.hpp	/^   int          visport;$/;"	m	class:MFEMBraidApp
visport	xbraid/drivers/braid_mfem_block.hpp	/^    int    visport;$/;"	m	class:MFEMBraidApp
visport_default	xbraid/drivers/braid_mfem.hpp	/^   static const int   visport_default;$/;"	m	class:MFEMBraidApp
visport_default	xbraid/drivers/braid_mfem.hpp	/^const int   MFEMBraidApp::visport_default = 19916;$/;"	m	class:MFEMBraidApp
visport_default	xbraid/drivers/braid_mfem_block.hpp	/^    static const int    visport_default;$/;"	m	class:MFEMBraidApp
visport_default	xbraid/drivers/braid_mfem_block.hpp	/^const int   MFEMBraidApp::visport_default = 19916;$/;"	m	class:MFEMBraidApp
warm_restart	xbraid/braid/_braid.h	/^   braid_Int              warm_restart;     \/**< boolean, indicates whether this is a warm restart of an existing braid_Core *\/$/;"	m	struct:_braid_Core_struct
weights	include/layer.hpp	/^      MyReal* weights;                     \/* Weight matrix, flattened as a vector *\/$/;"	m	class:Layer
weights_bar	include/layer.hpp	/^      MyReal* weights_bar;                 \/* Derivative of the Weight matrix*\/$/;"	m	class:Layer
weights_class_init	include/config.hpp	/^      MyReal weights_class_init;$/;"	m	class:Config
weights_init	include/config.hpp	/^      MyReal weights_init;$/;"	m	class:Config
weights_open_init	include/config.hpp	/^      MyReal weights_open_init;$/;"	m	class:Config
weightsclassificationfile	include/config.hpp	/^      const char* weightsclassificationfile;$/;"	m	class:Config
weightsopenfile	include/config.hpp	/^      const char* weightsopenfile;$/;"	m	class:Config
wrapper_test	xbraid/braid/_braid.h	/^   braid_Int     wrapper_test;     \/**< boolean describing whether this call is only a wrapper test *\/$/;"	m	struct:_braid_Core_struct
wrapper_tests	xbraid/examples/ex-01-expanded-f.f90	/^   integer max_iter, fmg, wrapper_tests,/;"	v	program:ex01_f90
write	pythonutil/config.py	/^    def write(self,filename=''):$/;"	m	class:Config
x	xbraid/drivers/braid_mfem.hpp	/^   Array<ParGridFunction *>       x;  \/\/ auxiliary ParGridFunctions$/;"	m	class:MFEMBraidApp
x	xbraid/drivers/braid_mfem_block.hpp	/^    Array<ParGridFunction *>  x;        \/\/ auxiliary ParGridFunctions for block x$/;"	m	class:MFEMBraidApp
x	xbraid/drivers/viz-lorenz.py	/^x = data[:,0]$/;"	v
xstart	xbraid/drivers/viz-burgers-1D.py	/^xstart = float(data[4])$/;"	v
xstart	xbraid/examples/viz-ex-02.py	/^xstart = float(data[4])$/;"	v
xstop	xbraid/drivers/viz-burgers-1D.py	/^xstop = float(data[5])$/;"	v
xstop	xbraid/examples/viz-ex-02.py	/^xstop = float(data[5])$/;"	v
xticks	xbraid/misc/user_utils/cycleplot.py	/^      xticks = arange( level.shape[0] )[new_iterations]$/;"	v
y	include/hessianApprox.hpp	/^      MyReal* y; $/;"	m	class:BFGS
y	include/hessianApprox.hpp	/^      MyReal** y;             \/* storing M (\\nabla f_{k+1} - \\nabla f_k) vectors *\/$/;"	m	class:L_BFGS
y	xbraid/drivers/viz-lorenz.py	/^y = data[:,1]$/;"	v
yticks	xbraid/misc/user_utils/cycleplot.py	/^         yticks = [ma, 10**((log10(mi)+log10(ma))*1.\/3.), 10**((log10(mi)+log10(ma))*2.\/3.), mi ]$/;"	v
yticks	xbraid/misc/user_utils/cycleplot.py	/^      yticks = range(int(min(level)), int(max(level)+1))$/;"	v
z	xbraid/drivers/viz-lorenz.py	/^z = data[:,2]$/;"	v
~Arnoldi	xbraid/drivers/mfem_arnoldi.hpp	/^        ~Arnoldi()$/;"	f	class:Arnoldi
~BraidAccessStatus	xbraid/braid/braid.hpp	/^      ~BraidAccessStatus() { }$/;"	f	class:BraidAccessStatus
~BraidApp	xbraid/braid/braid.hpp	/^   virtual ~BraidApp() { }$/;"	f	class:BraidApp
~BraidBufferStatus	xbraid/braid/braid.hpp	/^      ~BraidBufferStatus() {} $/;"	f	class:BraidBufferStatus
~BraidCoarsenRefStatus	xbraid/braid/braid.hpp	/^      ~BraidCoarsenRefStatus() { }$/;"	f	class:BraidCoarsenRefStatus
~BraidCore	xbraid/braid/braid.hpp	/^   ~BraidCore() { braid_Destroy(core); }$/;"	f	class:BraidCore
~BraidStepStatus	xbraid/braid/braid.hpp	/^      ~BraidStepStatus() { }$/;"	f	class:BraidStepStatus
~BraidUtil	xbraid/braid/braid.hpp	/^   ~BraidUtil() { }$/;"	f	class:BraidUtil
~BraidVector	xbraid/drivers/braid_mfem_block.hpp	/^BraidVector::~BraidVector()$/;"	f	class:BraidVector
~MFEMBraidApp	xbraid/drivers/braid_mfem.hpp	/^MFEMBraidApp::~MFEMBraidApp()$/;"	f	class:MFEMBraidApp
~MFEMBraidApp	xbraid/drivers/braid_mfem_block.hpp	/^MFEMBraidApp::~MFEMBraidApp()$/;"	f	class:MFEMBraidApp
